<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多项式卷积</title>
    <link href="/2025/06/09/PolynomialConvlution/"/>
    <url>/2025/06/09/PolynomialConvlution/</url>
    
    <content type="html"><![CDATA[<p>FFT 和 NTT 都可以用于 $O(n \log n)$ 时间内求两个多项式&#x2F;数列的卷积.</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="多项式的两种表示方法"><a href="#多项式的两种表示方法" class="headerlink" title="多项式的两种表示方法"></a>多项式的两种表示方法</h3><h4 id="系数表示法"><a href="#系数表示法" class="headerlink" title="系数表示法"></a>系数表示法</h4><p>一般来说，我们表示一个多项式 $A(x)$ 通常以 $A(x) &#x3D; \sum a_i x^i$ 的形式，这被称为多项式的系数表示法，同时也可以写作一个向量的形式：$(a_0, a_1, \dots, a_n)$。可以发现，如果暴力的展开两个多项式的系数表示并分别相乘，时间复杂度是 $O(n^2)$ 的。</p><h4 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h4><p>对于一个 $n$ 次多项式 $A(x)$，将 $n$ 个不同的 $x_i$ 带入 $A(x)$，可以得到 $n$ 个不同的结果 $y_i$，结合简单线性代数知识，容易得到这 $n$ 个 $(x_i, y_i)$ 可以将 $A(x)$ 唯一确定。</p><p>当然你也可以说 $(y_1, y_2, \dots, y_n)$ 是 $(a_1, a_2, \dots, a_n)$ 的一个点值表示。</p><p>同时可以发现，如果我们已经得到了两个多项式的点值表示，那么将每个点对值相乘即可，这部分时间复杂度 $O(n)$，但是将系数表示转化为点值表示时间复杂度是 $O(n^2)$ 的。</p><p>将一个多项式的系数表示转换为点值表示的过程称为<strong>求值</strong>。将点值表示转换为系数表示的过程称为<strong>插值</strong>。</p><h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>以下内容均在<em>复数域</em>上研究：</p><p>我们称，所有满足 $\omega^n &#x3D; 1$，且幅角在 $(0, 2\pi]$ 内的 $\omega$ 为 $n$ 次单位根，容易单位根共有 $n$ 个，分别记作 $\omega_i^1,\omega_i^2 \dots \omega_i^n$。进一步的，还可以得到 $\omega_n^k$ 的幅角为 $\frac{2 k \pi}{n}$，模长为 $1$。</p><p>然后，可以得到 $\omega_n^{\frac{n}{2}} &#x3D; -1$，证明就是因为它的幅角就是 $\pi$。</p><p>FFT 便是将单位根与点值表示法进行结合。</p><h2 id="离散傅里叶变换（Discrete-Fourier-Transform-DFT）"><a href="#离散傅里叶变换（Discrete-Fourier-Transform-DFT）" class="headerlink" title="离散傅里叶变换（Discrete Fourier Transform, DFT）"></a>离散傅里叶变换（Discrete Fourier Transform, DFT）</h2><p>前面说到，一个 $n$ 次多项式可以被 $n$ 个点唯一确定。然后我们考虑将 $n$ 个 $n$ 次单位根带入（这个过程就是 <em>DFT</em>）。但是这依旧是 $O(n^2)$ 的，优化就需要利用<em>快速傅里叶变换</em>。</p><h2 id="快速傅里叶变换（Fast-Fourier-Transform-FFT）"><a href="#快速傅里叶变换（Fast-Fourier-Transform-FFT）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transform, FFT）"></a>快速傅里叶变换（Fast Fourier Transform, FFT）</h2><p>观察性质：</p><p>现有一多项式 $A(x) &#x3D; \sum_{i&#x3D; 0}^n a_i x^i$，将其每一项按照幂次奇偶性分类：<br>$$<br>A(x) &#x3D; \sum_{i &#x3D; 0} a_{2i}x^{2i} + \sum_{i &#x3D; 0} a_{2i + 1}x^{2i + 1}<br>$$<br>设另有两个多项式：<br>$$<br>\begin{align}<br>A_1(x) &amp; &#x3D;  \sum_{i &#x3D; 0} a_{2i}x^i\newline<br>A_2(x) &amp; &#x3D;  \sum_{i &#x3D; 0} a_{2i + 1}x^i<br>\end{align}<br>$$<br>然后得到：<br>$$<br>A(x) &#x3D; A_1(x^2) + xA_2(x^2)<br>$$<br>如果我们将 $\omega_n^k$ 带入的话：<br>$$<br>A(\omega_n^k) &#x3D; A_1(\omega_n^{2k}) + \omega_n^kA_2(\omega_n^{2k})<br>$$<br>我们还可以将 $\omega_n^{k + \frac{n}{2}}$ 带入：<br>$$<br>\begin{align}<br>A(\omega_n^{k + \frac{n}{2}}) &amp; &#x3D; A_1(\omega_n^{2k + n}) + \omega_n^{k + \frac{n}{2}}A_2(\omega_n^{2k + n}) \newline<br>&amp; &#x3D; A_1(\omega_n^{2k}) - \omega_n^{k}A_2(\omega_n^{2k}) \newline<br>\end{align}<br>$$<br>因此我们发现对于两项 $i$ 和 $i + \frac{n}{2}$，他们的取值只有一处符号上都区别，那么这两个东西就可以同时计算，因此我们将问题规模缩小了一半，然后递归计算 $A_1$ 和 $A_2$。</p><h2 id="离散傅里叶逆变换（Inverse-Discrete-Fourier-Transform-IDFT）"><a href="#离散傅里叶逆变换（Inverse-Discrete-Fourier-Transform-IDFT）" class="headerlink" title="离散傅里叶逆变换（Inverse Discrete Fourier Transform, IDFT）"></a>离散傅里叶逆变换（Inverse Discrete Fourier Transform, IDFT）</h2><p>但是问题并没有结束，解决了将系数表示转换为点值表示后，进行乘法，最终还需要将关于单位根的点值表示转换为系数表示，这个过程叫<em>离散傅里叶逆变换</em>。</p><p>设 $(y_1, y_2, \dots, y_n)$ 是 $A(x) &#x3D; (a_1, a_2, \dots, a_n)$ 的一个点值表示，同时把 $(y_1, y_2, \dots, y_n)$ 也看作一个多项式，那么同时有 $\mathbf c &#x3D; (c_1, c_2, \dots, c_n)$ 满足：<br>$$<br>c_k &#x3D; \sum_{i &#x3D; 0}^{n - 1} y_i (\omega_n^{-k})^i<br>$$<br>然后推式子：<br>$$<br>\begin{align}<br>c_k &amp; &#x3D; \sum_{i &#x3D; 0}^{n - 1} \sum_{j &#x3D; 0}^{n - 1} a_j (\omega_n^{i})^j (\omega_n^{-k})^i\newline<br>&amp; &#x3D; \sum_{i &#x3D; 0}^{n - 1} \sum_{j &#x3D; 0}^{n - 1} a_j (\omega_n^{j})^i (\omega_n^{-k})^i\newline<br>&amp; &#x3D; \sum_{i &#x3D; 0}^{n - 1} \sum_{j &#x3D; 0}^{n - 1} a_j (\omega_n^{j - k})^i\newline<br>&amp; &#x3D; \sum_{j &#x3D; 0}^{n - 1} a_j \sum_{i &#x3D; 0}^{n - 1} (\omega_n^{j - k})^i\newline<br>\end{align}<br>$$<br>当 $j \neq k$ 时，我们将后边的部分等比数列求和：<br>$$<br>\begin{align}<br>&amp; &#x3D; \sum_{j &#x3D; 0, j \neq k}^{n - 1} a_j \frac{1 - (\omega_n^{j - k})^n}{1 - \omega_n^{j - k}}\newline<br>\end{align}<br>$$<br>那么就会发现，左边这个式子值为 $0$。</p><p>然后当 $j &#x3D; k$ 时，右边的东西显然是 $\sum_{i &#x3D; 0}^{n - 1} 1 &#x3D; n$。因此我们得到：<br>$$<br>\begin{align}<br>c_k &amp; &#x3D; na_k\newline<br>a_k &amp; &#x3D; \frac{c_k}{n}\newline<br>\end{align}<br>$$<br>因此，我们只要能够较快的求得 $\mathbf c$ 就可以 $O(n)$ 地求得两个多项式卷积的系数。</p><h2 id="快速傅里叶逆变换（Inverse-Fast-Fourier-Transform-IFFT）"><a href="#快速傅里叶逆变换（Inverse-Fast-Fourier-Transform-IFFT）" class="headerlink" title="快速傅里叶逆变换（Inverse Fast Fourier Transform, IFFT）"></a>快速傅里叶逆变换（Inverse Fast Fourier Transform, IFFT）</h2><p>注意到上面的 $\mathbf c$ 只需要修改 FFT 过程中的 $\omega$ 值即可，但是这里提供另一种方法：</p><blockquote><p>根据 $\omega_n^{-k} &#x3D; \omega_n^{n - k}$，我们只需要先对 $\mathbf y$ FFT，然后将 $1 \sim n - 1$ 中的序列 <code>reverse</code> 即可。</p></blockquote><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>FFT 实际上是一个类似于线段树的过程，因此可以猜测复杂度是 $O(n \log n)$。进一步的分析我们还可以结合主定理：<br>$$<br>T(n) &#x3D; 2T\left(\frac n 2\right) + O(n) \newline<br>\Rightarrow T(n) &#x3D; \Theta(n \log n)<br>$$<br>因此 FFT 时间复杂度得证。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>实现大体分两种：递归式<del>大常数预警</del>与迭代式。</p><h3 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;len, Complex *a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    Complex a1[len &gt;&gt; <span class="hljs-number">1</span>], a2[len &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>)<br>        a1[i &gt;&gt; <span class="hljs-number">1</span>] = a[i], a2[i &gt;&gt; <span class="hljs-number">1</span>] = a[i + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">fft</span>(len &gt;&gt; <span class="hljs-number">1</span>, a1, type), <span class="hljs-built_in">fft</span>(len &gt;&gt; <span class="hljs-number">1</span>, a2, type);<br>    Complex wn = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span> * pi / len), type * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span> * pi / len)&#125;, w = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (len &gt;&gt; <span class="hljs-number">1</span>); i++, w = w * wn) &#123;<br>        Complex tmp = w * a2[i]; <span class="hljs-comment">// 蝴蝶操作优化</span><br>        a[i] = a1[i] + tmp;<br>        a[i + (len &gt;&gt; <span class="hljs-number">1</span>)] = a1[i] - tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fft</span>(len, a, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">fft</span>(len, b, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) a[i] = a[i] * b[i];<br>    <span class="hljs-built_in">fft</span>(len, a, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + m; i++) ans[i] = <span class="hljs-built_in">int</span>(a[i].x / len + <span class="hljs-number">0.5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打注释的地方叫<em>蝴蝶操作</em>，注意到实际上应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a[i] = a1[i] + w * a2[i], a[i + (len &gt;&gt; <span class="hljs-number">1</span>)] = a1[i] - w * a2[i];<br></code></pre></td></tr></table></figure><p>我们发现复数的乘法带有比较大的常数，因此可以提前存下来变成两次加法。</p><blockquote><p>这个名字的由来是如果将 $A$ 在各处的点值画成一个长条形的数组，在数组下面一次依次是 n 次本原单位根的 $0 \sim m−1$ 次幂，则求值过程可以画成 $\omega_n^0$​ 连一条边向 $A(\omega_n^0),A(\omega_n^{\frac n 2 - 1}​)$；而 $\omega_n^0$​ 连一条边向 $A(\omega_n^1),A(\omega_n^{\frac n 2}​)$，以此类推。画出的图形如同蝴蝶的翅膀。——<a href="https://www.luogu.com.cn/article/ru1mw5wr">一扶苏一</a></p></blockquote><p>但是这个东西带有大常数，<del>根据雪猫线段树定理：线段树是根号算法</del>及其容易被卡常甚至跑不过暴力。为了解决这个问题我们尝试替换掉类似于线段树式的递归。</p><h3 id="迭代式"><a href="#迭代式" class="headerlink" title="迭代式"></a>迭代式</h3><p>递归是自上而下的，那么迭代一定考虑的是如何自下而上的合并每一次操作的答案，观察每一次操作的序列下标，有：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">step</span> <span class="hljs-number">1</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">step</span> <span class="hljs-number">2</span>: <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>,  <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">step</span> <span class="hljs-number">3</span>: <span class="hljs-number">0</span> <span class="hljs-number">4</span>,  <span class="hljs-number">2</span> <span class="hljs-number">6</span>,  <span class="hljs-number">1</span> <span class="hljs-number">3</span>,  <span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">step</span> <span class="hljs-number">4</span>: <span class="hljs-number">0</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>我们研究最后一层，也就是 <code>step 4</code>，观察他们的二进制表示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000</span>, <span class="hljs-number">100</span>, <span class="hljs-number">010</span>, <span class="hljs-number">110</span>, <span class="hljs-number">001</span>, <span class="hljs-number">011</span>, <span class="hljs-number">101</span>, <span class="hljs-number">111</span><br></code></pre></td></tr></table></figure><p>尝试反转二进制表示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000</span>, <span class="hljs-number">001</span>, <span class="hljs-number">010</span>, <span class="hljs-number">011</span>, <span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">101</span>, <span class="hljs-number">111</span><br></code></pre></td></tr></table></figure><p>就会发现上面的二进制是 $1\sim8$ 单调递增的排列，问题转变为，只要我们能快速计算反转二进制表示后的序列，就能得到合并序列的顺序。</p><p>理论上每一个 $O(\log n)$ 计算是可以的，但是有大常数。</p><p>这里提供一个常数更小的实现方式：</p><p>思路来自基数排序：</p><blockquote><p>我们可以将一个数的数位分为两半，先对后半部分数位构成的数进行排序，然后再对前半部分数位构成的数进行排序。两个数字的前半部分数位如果相同，那么它们的先后顺序即为后半部分数位的先后顺序。这样由于后半部分本身是有序的，就可以自低位向高位对数列进行排序。——<a href="https://www.luogu.com.cn/article/ru1mw5wr">一扶苏一</a></p></blockquote><p>考虑构造一个序列，初始时只有：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">000 </span><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>不难发现将每一个数的二进制表示反转后整个序列单调增。然后我们将第 $2$ 位（从右往左）的数字置为 $1$：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">010 </span><span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>把新得到的序列添加到原序列后边：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">000 </span><span class="hljs-number">100</span> <span class="hljs-number">010</span> <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>不难发现将每一个数的二进制表示反转后整个序列又是单调增的。我们似乎得到了一种可行的构造方案，怎么证明呢：</p><p>考虑数学归纳法：</p><ol><li>初始时反转二进制表示的序列是有序的</li><li>假设之前的序列反转后是有序的。注意到第 $i$ 次操作的时候，加入了大于 $i$ 位的位置都是 $0$，且第 $i$ 位是 $1$ 的所有数，他们显然比序列中原来存在的大于等于 $i$ 位的位置都是 $0$ 的数要大（并且之前存在的数字都满足这个条件），并且去掉 $1$ 以后即为序列中原有数字的顺序（反转后有序），得出加入后的序列反转后也是有序的。</li><li>由第一类数学归纳法可得此方案可行。</li></ol><p>我们一共要处理 $O(\log n)$ 位，每一位的处理都是 $O(n)$ 的，而且经常跑不满，那么实际复杂度应该是 $O(n \log n)$ 的。处理这部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d = len &gt;&gt; <span class="hljs-number">1</span>, p = <span class="hljs-number">0</span>;<br>    rev[p++] = <span class="hljs-number">0</span>;<br>    rev[p++] = d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt;= len; w &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        d &gt;&gt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; w; j++)<br>            rev[p++] = rev[j] | d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来问题是如何将原序列按反转后的顺序排好序。注意到一定有 <code>rev[rev[i]] = i</code>，因此对于一个下标 $p$，它反转之后的下标为 $q$，那么原序列中位置为 $q$ 的位置的值也一定要与 $p$ 交换，这样我们只当 <code>i &lt; rev[i]</code> 时交换即可。这个操作还有个名字，叫<em>位逆序置换</em>。</p><p>接下的部分就好办了，只要枚举每一次合并的长度按照之前递归式的做即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;len, Complex *a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;type)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>        <span class="hljs-keyword">if</span> (rev[i] &gt; i) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mid = <span class="hljs-number">1</span>; mid &lt; len; mid &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        Complex Wn = &#123;<span class="hljs-built_in">cos</span>(pi / mid), type * <span class="hljs-built_in">sin</span>(pi / mid)&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> L = mid &lt;&lt; <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; len; j += L) &#123;<br>            Complex w = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; mid; k++, w = Wn * w) &#123;<br>                Complex p = a[j + k], q = w * a[j + k + mid];<br>                a[j + k] = p + q, a[j + k + mid] = p - q;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三步变两步优化"><a href="#三步变两步优化" class="headerlink" title="三步变两步优化"></a>三步变两步优化</h3><p>按照我们之前的做法，首先分别求出 $A(x), B(x)$ 的 DFT，然后对数对相乘，最后在进行 IFFT 还原会系数表示。满打满算进行了 $3$ 次 FFT，实际上可以优化。</p><p>结论：</p><blockquote><p>得到多项式 $P(x) &#x3D; A(x) + iB(x)$，直接计算 $P^2(x)$ 即可，答案即为 $P$ 每一位系数的虚部的 $\frac 1 2$。</p></blockquote><p>证明：<br>$$<br>\begin{align}<br>P^2(x) &#x3D; (A(x) + iB(x))^2 &#x3D; A^2(x) - B^2(x) + 2iA(x)B(x)<br>\end{align}<br>$$<br>因此主函数可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) cin &gt;&gt; A[i].x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) cin &gt;&gt; A[i].y;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">init</span>(len);<br>    <span class="hljs-built_in">fft</span>(len, A, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) A[i] = A[i] * A[i];<br>    <span class="hljs-built_in">fft</span>(len, A, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + m; i++)<br>        cout &lt;&lt; <span class="hljs-built_in">int</span>(A[i].y / <span class="hljs-number">2</span> / len + <span class="hljs-number">0.5</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速数论变换（NTT）"><a href="#快速数论变换（NTT）" class="headerlink" title="快速数论变换（NTT）"></a>快速数论变换（NTT）</h2><p>浮点数的精度问题总是令人担忧, 避免浮点数则应该优化复数在 FFT 中的应用, 有没有与复数相似的结构呢? 原根便是其中之一.</p><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p><strong>阶</strong>: 使得 $a^n \equiv 1 \pmod m$ 的最小正整数 $n$ 称为 $a$ 模 $m$ 的阶, 记作 $n &#x3D; \delta_m(a)$.</p><p><strong>原根</strong>: 若 $\gcd(a, m) &#x3D; 1 \land \delta_m(a) &#x3D; \varphi(m)$, 称 $a$ 是 $m$ 的原根.</p><p><strong>原根存在定理</strong>: 一个数 $m$ 存在原根当且仅当 $m&#x3D;2,4,p^\alpha,2p^\alpha$, 其中 $p$ 为奇素数, $\alpha \in \mathbb N^∗$.</p><p><strong>原根判定定理</strong>: 设 $m \geq 3,\gcd(a,m)&#x3D;1$, 则 $a$ 是模 $m$ 的原根的充要条件是, 对于 $\varphi(m)$ 的每个质因数 $p$, 都有 $a^{\frac {\varphi(m)} p} \not\equiv 1 \pmod m$.</p><p><strong>原根个数</strong>: 若一个数有原根, 则它原根的个数为 $\varphi(\varphi(m))$.</p><h4 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h4><p>NTT 与 FFT 都是优化了复杂度的 DFT 的实现, 两者实际上本质相同, 只不过 FFT 更具有泛用性. NTT 可以用来解决模意义下的多项式乘法问题, 其运算均为整数, 精度方面优于 FFT.</p><p>将 FFT 改成 NTT 只需将 $\omega_n$ 改为 $g^{\frac{p - 1}{n}}$ 即可.</p><p>结合 DFT 可知, NTT 可以使用的充要条件是 $n$ 可整除 $p - 1$, 注意到我们一般会将 $n$ 补成 $2^k$, 也就是说只要满足 $p - 1 &#x3D; \xi 2^k$ ($k$ 不能太小) 即可. 那么 $998244353$ 就是比较合适的质数, 而 $10^9 + 7$ 不行.</p><table><thead><tr><th>模数 $p$</th><th>原根 $g$</th><th>备注</th></tr></thead><tbody><tr><td>$998244353$</td><td>$3$</td><td>$998244353 &#x3D; 119 \cdot 2^{23} + 1$</td></tr><tr><td>$167772161$</td><td>$3$</td><td>$167772161 &#x3D; 5 \cdot 2^{25} + 1$</td></tr><tr><td>$469762049$</td><td>$3$</td><td>$469762049 &#x3D; 2^{26} \cdot 7 + 1$</td></tr></tbody></table><p>以上都是可以做 NTT 的部分模数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">998244353</span>, g = <span class="hljs-number">3</span>, ginv = <span class="hljs-number">332748118</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>        <span class="hljs-keyword">if</span> (rev[i] &gt; i) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mid = <span class="hljs-number">1</span>; mid &lt; len; mid &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> gn = <span class="hljs-built_in">qpow</span>(type &gt; <span class="hljs-number">0</span> ? g : ginv, (mod - <span class="hljs-number">1</span>) / (mid &lt;&lt; <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> L = mid &lt;&lt; <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; len; j += L) &#123;<br>            <span class="hljs-type">int</span> G = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; mid; k++, (G *= gn) %= mod) &#123;<br>                <span class="hljs-type">int</span> p = a[j + k], q = G * a[j + k + mid] % mod;<br>                a[j + k] = (p + q) % mod, a[j + k + mid] = (p - q + mod) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="hljs-number">1</span>, d++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (d - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">ntt</span>(a, <span class="hljs-number">1</span>), <span class="hljs-built_in">ntt</span>(b, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) (a[i] *= b[i]) %= mod;<br>    <span class="hljs-built_in">ntt</span>(a, <span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">inv</span>(len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + m; i++)<br>        cout &lt;&lt; a[i] * tmp % mod &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n + m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效率大概是: <em>三步变两步 FFT &gt; NTT &gt; FFT</em>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数基础 (群环域理论)</title>
    <link href="/2025/06/08/Basic-Abstract-Algebra/"/>
    <url>/2025/06/08/Basic-Abstract-Algebra/</url>
    
    <content type="html"><![CDATA[<p>相比于其他学科而言, 抽象代数更多研究具有某些性质的代数结构, 而非具体的某种运算或数学元素. 抽象代数也可结合图论应用. 利用抽象代数描述某些算法更容易定义算法的可扩展范围.</p><h3 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h3><p>基础抽代的研究大多基于二元运算, 称 $\otimes$ 是 $G$ 上的<strong>二元运算</strong>, 当且仅当 $\forall x, y \in G, x \otimes y \in G$​ (也有人将其称为二元运算的封闭性).</p><h4 id="广义结合律"><a href="#广义结合律" class="headerlink" title="广义结合律"></a>广义结合律</h4><p><strong>广义结合律</strong>可以描述为: 对于系列二元运算, 运算的结果与加括号的形式无关. 例如: 矩阵乘法, 复数上的四则运算.</p><p>证明一个运算 $\otimes$ 具有广义结合律, 实际上只需证明 $(x \otimes y) \otimes z &#x3D; x \otimes(y \otimes z)$ (结合律).</p><blockquote><p>证明(假设 $(x \otimes y) \otimes z &#x3D; x \otimes(y \otimes z)$ 成立):</p><p>我们如下递归地定义运算顺序:<br>$$<br>x_1 \otimes x_2 \otimes \cdots \otimes x_n &#x3D; (x_1 \otimes x_2 \otimes \cdots \otimes x_{n - 1}) \otimes x_n<br>$$<br>进而我们发现, 结合律等价于:<br>$$<br>(x_1 \otimes \cdots \otimes x_n) \otimes (y_1 \otimes \cdots \otimes y_m) &#x3D; x_1 \otimes \cdots \otimes x_n \otimes y_1 \otimes \cdots \otimes y_m<br>$$<br>也就是说只需证明上式成立, 考虑数学归纳:</p><p>$m &#x3D; 1$ 时, 原式显然成立.</p><p>假设 $(x_1 \otimes \cdots \otimes x_n) \otimes (y_1 \otimes \cdots \otimes y_m) &#x3D; x_1 \otimes \cdots \otimes x_n \otimes y_1 \otimes \cdots \otimes y_m$ 成立.</p><p>那么:<br>$$<br>\begin{aligned}<br>&amp; x_1 \otimes \cdots \otimes x_n \otimes y_1 \otimes \cdots \otimes y_m \otimes y_{m + 1}\newline<br>&#x3D;&amp; (x_1 \otimes \cdots \otimes x_n) \otimes (y_1 \otimes \cdots \otimes y_m) \otimes y_{m + 1}\newline<br>&#x3D;&amp; (x_1 \otimes \cdots \otimes x_n) \otimes ((y_1 \otimes \cdots \otimes y_m) \otimes y_{m + 1})\newline<br>&#x3D;&amp; (x_1 \otimes \cdots \otimes x_n) \otimes (y_1 \otimes \cdots \otimes y_m \otimes y_{m + 1})<br>\end{aligned}<br>$$<br>根据数学归纳法, 问题得证.</p></blockquote><h4 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h4><p>大部分运算都不具有交换律, 这点需要清楚.</p><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><h4 id="半群"><a href="#半群" class="headerlink" title="半群"></a>半群</h4><p>对于非空集合 $G$ 和其上的二元运算 $\otimes$, 如果该运算满足结合律, 则称 $(G,\otimes)$​ 是一个<strong>半群</strong> (semigroup).</p><p>值得注意的是, 线段树可以维护半群 (标记可合并).</p><h4 id="幺半群"><a href="#幺半群" class="headerlink" title="幺半群"></a>幺半群</h4><p>对于半群 $(G, \otimes)$, 如果它还存在单位元 (幺), 则称 $(G,\otimes)$ 是一个<strong>幺半群</strong>（monoid).</p><blockquote><p>什么是<strong>幺</strong>:</p><p>幺在汉语中具有 $1$ 的含义 (幺九牌). 若 $e$ 满足 $e \otimes x &#x3D; x \otimes e &#x3D; x$, 则称 $e$ 是二元运算 $\otimes$ 的幺.</p><p>不难发现一种二元运算最多只有一个幺, 考虑反证:</p><p>假设 $e_1 \neq e_2$, 则<br>$$<br>e_1 \otimes e_2 &#x3D; e_2 \otimes e_1 &#x3D; e_2 &#x3D; e_1<br>$$<br>与假设相悖, 因此原命题成立.</p></blockquote><p>必须清楚<strong>具有幺元不代表具有交换律.</strong></p><h4 id="群-1"><a href="#群-1" class="headerlink" title="群"></a>群</h4><p>群是对幺半群限制更紧的情况. 对于幺半群 $(G, \otimes)$, 若满足 $\forall x \in G, \exists y \in G, x \otimes y &#x3D; y \otimes x &#x3D; e$, 则称 $(G, \otimes)$ 构成<strong>群</strong> (group), 其中, 我们称 $y$ 是 $x$ 的<strong>逆元</strong>, 记作 $y &#x3D; x^{-1}$.</p><blockquote><p>逆元的唯一性:</p><p>依旧考虑反证法:</p><p>假设 $y_1 \neq y_2$, 则<br>$$<br>y_1 &#x3D; y_1 \otimes e &#x3D; y_1 \otimes x \otimes y_2 &#x3D; e \otimes y_2 &#x3D; y_2<br>$$<br>与假设相悖, 因此原命题成立.</p></blockquote><p>必须清楚<strong>对于任意元素都具有逆元依旧不代表具有交换律.</strong></p><h4 id="Abel-群"><a href="#Abel-群" class="headerlink" title="Abel 群"></a>Abel 群</h4><p>又译阿贝尔群; 又名交换群.</p><p>对于群 $(G, \otimes)$, 若满足 $\forall x, y \in G, x \otimes y &#x3D; y \otimes x$ (交换律), 则称 $(G, \otimes)$ 构成<strong>Abel 群</strong> (Abelian group) 或<strong>交换群</strong> (communicate group).</p><h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>对于非空集合 $G$ 和其上的两个二元运算 $+:G\times G\rightarrow G$ 和 $\cdot:G\times G\rightarrow G$, 如果它们满足以下性质，则称 $(G,+,\cdot)$ 是一个<strong>环</strong> (ring):</p><ul><li>$(G,+)$ 构成 Abel 群, 其单位元记作 $0$, 元素 $a\in G$ 在 $+$ 下的逆元记作 $-a$;</li><li>$(G,\cdot)$ 构成半群, 即 $\cdot$ 满足结合律;</li><li><strong>分配律</strong> (distributive property): 对于所有 $a,b,c\in G$，成立 $a\cdot(b+c)&#x3D;a\cdot b+a\cdot c$ 和 $(a+b)\cdot c&#x3D;a\cdot c+b\cdot c$.</li></ul><p>为表述方便, 这两个二元运算 $+$ 和 $\cdot$​ 常称作该环的加法和乘法, 相应地, 加法单位元称作<strong>零元</strong> (zero), 乘法单位元 (如果存在) 称作<strong>幺元</strong> (identity). <strong>千万不要将环的加法乘法与复数上的加法乘法相混淆</strong>.</p><p>继承环的定义, 进一步加以限制, 得到:</p><ul><li>如果 $(G, \cdot)$ 构成幺半群, 那么称为幺环.</li><li>如果 $(G, \cdot)$​ 构成群, 那么称为除环.</li><li>如果 $\cdot$ 具有交换律, 那么称为交换环.</li></ul><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域是比环限制还要强的代数结构:</p><p>简单来说, 要求 $(G, \cdot)$​ 构成 Abel 群, 那么称为<strong>域</strong>或<strong>交换除环</strong>. 换句话说, 域是对加减乘除四则运算都封闭的代数结构.</p><p>举例而言:</p><ul><li>复数域: 复数在通常意义的加法和乘法下构成域。</li><li>有限域 (finite field): 以质数 $p$ 为模的整数同余类的集合 $\mathbf Z&#x2F;p\mathbf Z$ 在同余类的加法和乘法下构成域. 当然, 除此之外还有其他的有限域, 它们的结构由其大小唯一确定, 且大小必然是质数幂的形式.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k 短路</title>
    <link href="/2025/06/03/k-thPath/"/>
    <url>/2025/06/03/k-thPath/</url>
    
    <content type="html"><![CDATA[<p>简单口胡.</p><p>首先在反图上跑 dij 建最短路树, 那么为什么是反图呢, 显然你要知道每个点到终点的最短距离, 这个与你从哪里扩展有关. 因为一开始从 $1$ 不断扩展, 所以 $1 \rightarrow x$ 的长度你是知道的, 其余的路径只剩 $x \rightarrow n$ 了.</p><p>然后有重边, 要注意.</p><p>剩下的就可以看题解了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">5010</span>, MAXM = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, cnt, ans, fa[MAXN], from[MAXN], sec[MAXN], rt[MAXN];<br>bitset&lt;MAXN&gt; vis;<br><span class="hljs-type">double</span> E, dis[MAXN];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-type">double</span> w;<br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-built_in">Edge</span>() &#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> V, <span class="hljs-type">double</span> W, <span class="hljs-type">int</span> Id) : <span class="hljs-built_in">v</span>(V), <span class="hljs-built_in">w</span>(W), <span class="hljs-built_in">id</span>(Id) &#123;&#125;<br>&#125;;<br>vector&lt;Edge&gt; g[MAXN], h[MAXN];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> lc, rc;<br>    <span class="hljs-type">double</span> sum;<br>    <span class="hljs-type">int</span> dep, fa;<br>&#125; t[MAXM];<br><span class="hljs-type">int</span> tot;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nw</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">double</span> val)</span> </span>&#123;<br>    t[++tot] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, val, <span class="hljs-number">0</span>, f&#125;;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!x || !y) <span class="hljs-keyword">return</span> x | y;<br>    <span class="hljs-keyword">if</span> (t[x].sum &gt; t[y].sum) <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-type">int</span> p = ++tot;<br>    t[p] = t[x];<br>    t[p].rc = <span class="hljs-built_in">merge</span>(t[p].rc, y);<br>    <span class="hljs-keyword">if</span> (t[t[p].lc].dep &lt; t[t[p].rc].dep) <span class="hljs-built_in">swap</span>(t[p].lc, t[p].rc);<br>    t[p].dep = t[t[p].rc].dep + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dis[i] = INFINITY;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">emplace</span>(dis[n] = <span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [c, u] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>;<br>        vis[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w, id] : h[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dis[v] &gt; c + w) pq.<span class="hljs-built_in">emplace</span>(dis[v] = c + w, v), from[v] = id, fa[v] = u;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; E;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> u, v;<br>        <span class="hljs-type">static</span> <span class="hljs-type">double</span> w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            i--, m--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        g[u].<span class="hljs-built_in">emplace_back</span>(v, w, ++cnt);<br>        h[v].<span class="hljs-built_in">emplace_back</span>(u, w, cnt);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) sec[i] = i;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-built_in">sort</span>(sec + <span class="hljs-number">1</span>, sec + <span class="hljs-number">1</span> + n, [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> dis[a] &lt; dis[b]; &#125;);<br>    t[<span class="hljs-number">0</span>].dep = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> u = sec[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w, id] : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (id == from[u]) <span class="hljs-keyword">continue</span>;<br>            rt[u] = <span class="hljs-built_in">merge</span>(rt[u], <span class="hljs-built_in">nw</span>(v, w - dis[u] + dis[v]));<br>        &#125;<br>        rt[u] = <span class="hljs-built_in">merge</span>(rt[u], rt[fa[u]]);<br>    &#125;<br><br>    E -= dis[<span class="hljs-number">1</span>], ans = <span class="hljs-number">1</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">emplace</span>(t[rt[<span class="hljs-number">1</span>]].sum, rt[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [c, v] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (E &lt; c + dis[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-number">0</span>;<br>        E -= c + dis[<span class="hljs-number">1</span>], ans++;<br>        <span class="hljs-keyword">if</span> (t[v].lc) pq.<span class="hljs-built_in">emplace</span>(c - t[v].sum + t[t[v].lc].sum, t[v].lc);<br>        <span class="hljs-keyword">if</span> (t[v].rc) pq.<span class="hljs-built_in">emplace</span>(c - t[v].sum + t[t[v].rc].sum, t[v].rc);<br>        <span class="hljs-keyword">if</span> (rt[t[v].fa]) pq.<span class="hljs-built_in">emplace</span>(c + t[rt[t[v].fa]].sum, rt[t[v].fa]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hall 婚配定理</title>
    <link href="/2025/05/30/Hall-sTheorem/"/>
    <url>/2025/05/30/Hall-sTheorem/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚树</title>
    <link href="/2025/05/29/VirtualTree/"/>
    <url>/2025/05/29/VirtualTree/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/image-20250602100242869.png" alt="sb jpdh 配错数据"></p><p>虚树处理树上一些关键点与树上其他点之间计算贡献的一类问题, 虚树的时间复杂度与关键点的数量强相关, 因此, 虚树的题目一般带有 $\sum m \leq 10^5$​ 等数据范围.</p><p><img src="/../img/graph.png" alt="graph"></p><p>举例而言我们有这样一棵树, 加粗的点是关键点. 我们想用一棵树来描述树上其他点与关键点之间的关系, 怎么办呢?</p><p>浅显的做法是, 关键点之间按树上深度关系连边:</p><p><img src="/../img/graph1.png"></p><p>但是注意到这样难以计算 $1 \rightarrow 6$ 这条边的贡献, 启发我们还应该向关键点之间的 lca 连边.</p><p><img src="/../img/graph2.png"></p><p>这个过程可以按 dfn 序排序后用深度的单调栈每次插入一个新点即可, 建树复杂度 $O(n)$.</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="CF613D"><a href="#CF613D" class="headerlink" title="CF613D"></a>CF613D</h4><p>模板</p><h4 id="P3233"><a href="#P3233" class="headerlink" title="P3233"></a>P3233</h4><p>注意到每个关键管辖的部分在一条链上是连续的, 倍增一条链, 找中间分界点.</p><h4 id="P4103"><a href="#P4103" class="headerlink" title="P4103"></a>P4103</h4><p>较为简单的虚树上 DP, 但是虚树上点分治应该也行. </p><h4 id="P4426"><a href="#P4426" class="headerlink" title="P4426"></a>P4426</h4><p>虚树上 DP, 但是问题在于非关键点也会对关键点的 DP 造成影响, 手玩后发现非关键点对于关键点而言只是一个系数. 做法是预处理虚树上每条链的系数, 然后 DP <del>大码量预警</del>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态 DP</title>
    <link href="/2025/05/29/DDP/"/>
    <url>/2025/05/29/DDP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>矩阵可以非常方便的描述一个向量&#x2F;变量的变化情况, DDP 就是基于(广义)矩阵乘法的结合律(tag 可合并)实现的。</p></blockquote><p>DDP 一般解决较为简单的 DP 问题, 但是带修改的情况.</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><a href="https://www.luogu.com.cn/problem/AT_abc246_h">ABC246Ex 01? Queries</a></p><p>给定长度为 $N$ 的仅包含 <code>0</code>, <code>1</code>, <code>?</code> 的字符串 $S$, 给定 $Q$ 组询问 $(x_1,c_1),(x_2,c_2),\cdots,(x_q,c_q)$, 每次将原字符串中 $x_i$ 位置的字符改为 $c_i$, 然后输出 $S$ 有多少种非空子序列, <code>?</code> 需任意替换为 <code>0</code> 或 <code>1</code>.</p><p>如果不带修, 就可以直接 DP 了.</p><p>那考虑带修改怎么做? 先将转移方程用矩阵表示:<br>$$<br>\mathbf S_{a_i} \begin{bmatrix}f_{i-1,0}\newline f_{i-1,1}\newline 1 \end{bmatrix} &#x3D; \begin{bmatrix} f_{i,0}\newline f_{i,1}\newline 1 \end{bmatrix}<br>$$<br>不难得到:<br>$$<br>\mathbf S_{\texttt{0}}&#x3D;<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1\newline<br>0 &amp; 1 &amp; 0\newline<br>0 &amp; 0 &amp; 1<br>\end{bmatrix},<br>\mathbf S_{\texttt{1}}&#x3D;<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\newline<br>1 &amp; 1 &amp; 1\newline<br>0 &amp; 0 &amp; 1<br>\end{bmatrix},<br>\mathbf S_{\texttt{?}}&#x3D;<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1\newline<br>1 &amp; 1 &amp; 1\newline<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>由于矩阵乘法具有结合律, 可以用线段树维护, 修改时直接修改对应位置的转移矩阵即可。</p><h3 id="广义矩阵乘法"><a href="#广义矩阵乘法" class="headerlink" title="广义矩阵乘法"></a>广义矩阵乘法</h3><p>大部分情况下, 状态转移方程会不可避免的带有 $\min&#x2F;\max$, 此时一般的矩阵乘法无法刻画转移过程, 我们引入广义矩阵乘法.</p><p>广义矩阵乘法并不是某一种具体的运算, 它代表了一系列具有结合律的矩阵间的运算, 举例而言:</p><p>定义两 $n$ 阶方阵间运算 $\mathbf A \otimes \mathbf B &#x3D; \mathbf C$:<br>$$<br>c_{ij} &#x3D; \max_{k &#x3D; 0} {a_{ik} + b_{kj}}<br>$$<br>不难发现运算 $\otimes$ (值得一提的是, 我们可以把 $\otimes$ 称作 $(\max, +)$ 规则下的矩阵乘法)具有结合律, 以抽象代数的语言表示的话, 即 $(\mathbf M_n, \otimes)$ 是一个幺半群(不难发现矩阵 $\begin{bmatrix}0 &amp; +\infty &amp;\cdots &amp; +\infty \newline +\infty &amp;0 &amp;\cdots &amp;+\infty\newline\vdots &amp;&amp; \ddots &amp;\vdots\newline +\infty &amp;\cdots &amp;&amp; 0\end{bmatrix}$​ 是它的幺元).</p>证明:由群论基本知识得到, 欲证明 $\otimes$ 具有结合律, 只需证明 $(\mathbf A \otimes \mathbf B) \otimes \mathbf C = \mathbf A \otimes (\mathbf B \otimes \mathbf C)$: 设 $\mathbf A \otimes \mathbf B = \mathbf D, \mathbf B \otimes \mathbf C = \mathbf E$​. 左为:$$\begin{aligned}\max_{k = 0}^n \{d_{ik} + c_{kj}\} &= \max_{k = 0}^n \left\{\max^n_{t = 0} \{a_{it} + b_{tk}\} + c_{kj} \right\}\newline&= \max^n_{k = 0} \left\{\max^n_{t = 0} \{a_{it} + b_{tk} + c_{kj}\} \right\}\end{aligned}$$同理对右边操作:$$\begin{aligned}\max_{k = 0}^n \{a_{ik} + e_{kj}\} &= \max_{k = 0}^n \left\{a_{ik} + \max^n_{t = 0} \{d_{kt} + c_{tj}\} \right\}\newline&= \max^n_{k = 0} \left\{\max^n_{t = 0} \{a_{ik} + b_{kt} + c_{tj}\} \right\}\end{aligned}$$那很容易就能发现两者等价了, 因此原问题得证.<blockquote><p>进一步观察证明过程, 不难发现关键的一步成立对应的条件是 $+$ 对 $\max$ 具有分配律, 也就是$(\mathbb R, \max, +)$ 构成一个环. 那么进一步扩展得到结论: <strong>任何具有分配律的二则运算 $(\odot, \oplus)$ 规则下的矩阵乘法都满足结合律</strong>(也可以表述成: <strong>若 $(\mathbb R, \odot, \oplus)$ 构成一个环, 则 $(\odot, \oplus)$ 规则下的矩阵乘法 $(\mathbf M_n,\otimes)$ 构成一个半群</strong>). 举例来说: $(\min, \pm)$, $(\max, \pm)$, $(\land, \lor)$ 规则下的矩阵乘法都具有结合律.</p></blockquote><p>半群最大的好处在于可以利用线段树维护, 完成快速修改和快速计算, 因此 DDP 的代码一般来说都是广义矩阵乘法与线段树的结合.</p><h3 id="P4719-【模板】动态-DP"><a href="#P4719-【模板】动态-DP" class="headerlink" title="P4719 【模板】动态 DP"></a>P4719 【模板】动态 DP</h3><blockquote><p> DDP 最常用即为解决树上带修问题.</p></blockquote><p>求最大权独立集, 带修改.</p><p>一般的最大权独立集是简单的: 设 $f_{i, 0&#x2F;1}$ 表示强制选&#x2F;不选 $i$ 号节点的答案, 转移有:<br>$$<br>\begin{aligned}<br>f_{i, 0} &amp;&#x3D; \sum\max{f_{v, 1}, f_{v, 0}} \newline<br>f_{i, 1} &amp;&#x3D; w_i + \sum f_{v, 0}<br>\end{aligned}<br>$$<br>修改让我们想到树链剖分, 但是线段树维护树链时重儿子和轻儿子的转移应当是不同的, 套路是设 $g_{i, 0&#x2F;1}$ 强制选&#x2F;不选节点 $i$, 并且只考虑 $i$ 的轻儿子的结果, 转移有:<br>$$<br>\begin{aligned}<br>f_{i, 0} &amp;&#x3D; g_{i, 0} + \max{f_{v, 1}, f_{v, 0}} \newline<br>f_{i, 1} &amp;&#x3D; g_{i, 1} + w_i + f_{v, 0}<br>\end{aligned}<br>$$<br>写作矩阵乘法:<br>$$<br>\begin{bmatrix}g_{i, 0} &amp; g_{i, 0} \newline g_{i, 1} &amp; -\infty \end{bmatrix}<br>\begin{bmatrix}f_{j, 0} \newline f_{j, 1} \end{bmatrix} &#x3D; \begin{bmatrix}f_{i, 0} \newline f_{i, 1} \end{bmatrix}<br>$$<br>提前预处理 $g$, 修改时差分保证复杂度即可.</p>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC Trick 整理</title>
    <link href="/2025/05/27/TrickInABC/"/>
    <url>/2025/05/27/TrickInABC/</url>
    
    <content type="html"><![CDATA[<h3 id="ABC407F"><a href="#ABC407F" class="headerlink" title="ABC407F"></a>ABC407F</h3><p>直接做一定是不好做的，那么考虑拆贡献。一个数字 $a_i$ 个贡献与<strong>它左边第一个大于它的位置</strong> $L_i$ 和<strong>它右边第一个大于它的位置</strong> $R_i $有关，推式子后贡献形如分段函数，每一段都是一次函数，累计到答案上即可。$L_i, R_i$ 可以利用单调栈求。</p><h3 id="ABC407G"><a href="#ABC407G" class="headerlink" title="ABC407G"></a>ABC407G</h3><p>大概是典题，简单转化之后求二分图最小权匹配，可以用费用流做。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数奇妙题</title>
    <link href="/2024/11/01/%E8%AE%A1%E6%95%B0%E5%A5%87%E5%A6%99%E9%A2%98(Updated)/"/>
    <url>/2024/11/01/%E8%AE%A1%E6%95%B0%E5%A5%87%E5%A6%99%E9%A2%98(Updated)/</url>
    
    <content type="html"><![CDATA[<h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><blockquote><p>由于之前对<strong>钦定</strong>与<strong>恰好</strong>间有诸多误解，重整理一遍。</p></blockquote><p>二项式反演有两种常用形式：</p><p>形式一：<br>$$<br>f(n)  &#x3D; \sum_{i &#x3D; 0}^{n} {n \choose i} g(i)<br>\Longleftrightarrow<br>g(n)  &#x3D; \sum_{i &#x3D; 0}^{n} (-1)^{n - i} {n \choose i} f(i)<br>$$<br>形式二：<br>$$<br>f(n)  &#x3D; \sum_{i &#x3D; n}^{m} {i \choose n} g(i) \Longleftrightarrow<br>g(n)  &#x3D; \sum_{i &#x3D; n}^{n} (-1)^{i - n} {i \choose n} f(i)<br>$$</p><p>由于不难发现以上两者等价，因此证明任意一个即可：</p><p>直接将上式代入到下式中，如果成立则二项式反演显然成立：<br>$$<br>\begin{aligned}<br>g(n) &amp;&#x3D; \sum_{i &#x3D; 0}^{n} (-1)^{n - i} {n \choose i} \sum_{j &#x3D; 0}^{i} {i \choose j} g(j)\newline<br>&amp;&#x3D; \sum_{i &#x3D; 0}^{n} \sum_{j &#x3D; 0}^{i} (-1)^{n - i} {n \choose i} {i \choose j} g(j)\newline<br>&amp;&#x3D; \sum_{i &#x3D; 0}^{n} \sum_{j &#x3D; 0}^{i} (-1)^{n - i} {n \choose j} {n - j \choose i - j} g(j)\newline<br>&amp;&#x3D; \sum_{j &#x3D; 0}^{n}  g(j)  {n \choose j} \sum_{i &#x3D; j}^{n} (-1)^{n - i} {n - j \choose i - j}\newline<br>&amp;&#x3D; \sum_{j &#x3D; 0}^{n}  g(j)  {n \choose j} \sum_{k &#x3D; 0}^{n - j} (-1)^{(n - j) - k} {n - j \choose k}\newline<br>&amp;&#x3D; \sum_{j &#x3D; 0}^{n}  g(j)  {n \choose j} \sum_{k &#x3D; 0}^{n - j} (-1)^{(n - j) - k} 1^k {n - j \choose k}<br>\end{aligned}<br>$$<br>最后的部分利用二项式定理，$n - j &#x3D; 0$ 时单独算，得到：</p><p>$$<br>\begin{aligned}<br>g(n) &amp;&#x3D; \sum_{j &#x3D; 0}^{n}  g(j)  {n \choose j} [n &#x3D; j]\newline<br>&amp;&#x3D; g(n) {n \choose n} &#x3D; g(n)<br>\end{aligned}<br>$$</p><blockquote><p><strong>钦定</strong>与<strong>恰好</strong>：</p><p>我们经常会遇到：求恰好有 $n$ 个位置满足条件的方案数或求至少 $n$ 个位置满足条件的方案数，因为后者我们可以对前者做和得到，即只要完成前者，则两个问题都可以被解决。</p><p>这里，我们设 $f(n)$ 表示钦定有 $n$ 个位置满足要求、其余位置随意的方案数，$g(n)$ 表示恰好 $n$ 个位置满足要求的方案数。枚举我们所钦定的位置是什么，不难得到以下关系 $f(n)  &#x3D; \sum_{i &#x3D; n}^{m} {i \choose n} g(i)$，然后可以二项式反演。</p><p>然而，问题在于，初学者经常无法理解<em>钦定</em>与<em>至少</em>间的差别，这里我们举以下例子：</p><p><code>1 0 0 1 0 1 1</code> 是一个状态，它会在至少有 $1, 2, 3, 4$ 符合要求的时候被计算一次贡献。但是，注意，它会在钦定有 $2$ 个位置满足要求时被统计 $4 \choose 2$ 次，二项式系数取决于 $4$ 个 $1$ 中的哪两个位置是被钦定的，当钦定 $1, 3, 4$ 个位置满足要求时同理。</p></blockquote><h2 id="CF285E"><a href="#CF285E" class="headerlink" title="CF285E"></a>CF285E</h2><p>设<strong>钦定</strong>有 $m$ 部分符合要求的方案数为 $f(m)$，<strong>恰好</strong>有 $m$ 部分符合要求的方案数为 $g(m)$，那么有：<br>$$<br>f(m) &#x3D; \sum_{i &#x3D; m}^n {i \choose m} g(i)<br>$$<br>其中 $i \choose m$ 指的是枚举 $f(m)$ 的 $m$ 个数分别代表了 $g(i)$ 中 $i$ 个位置的哪 $m$ 个。这个时候我们二项式反演：<br>$$<br>g(m) &#x3D; \sum_{i &#x3D; m}^n (-1)^{i - m} {i \choose m} f(i)<br>$$<br>就可以通过 $f$ 得到答案 $g(m)$。</p><p>函数 $f$ 可以通过 dp 求得。具体的，设 $dp_{i, j, 0&#x2F;1, 0&#x2F;1}$ 表示考虑到前 $i$ 个数，有 $j$ 部分满足要求，$i&#x2F;i + 1$ 选或不选，转移：</p><ul><li>当前位置是完美数，选 $i - 1$；</li><li>当前位置是完美数，选 $i + 1$；</li><li>当前位置不是完美数。</li></ul><p>以上三种情况分类讨论即可。得到 $f(i) &#x3D; dp_{n, m, 0, 0} + dp_{n, m, 1, 0}$。</p><h2 id="AGC024E"><a href="#AGC024E" class="headerlink" title="AGC024E"></a>AGC024E</h2><p>正难则反，考虑我们已经有了长度为 $n$ 的 $A_n$，相当于每一次删去一个字符，并且字典序单调递减。考虑什么时候字典序会增加，那么就是删掉的 $s_i &lt; s_{i + 1}$。设 $f_{i, j}$ 表示长度为 $i$ 的串、使用的字符集大小为 $[1, j]$，在转移时我们枚举 $1$ 的位置，假设他在第 $p$ 个时刻后被删除，那么有：<br>$$<br>\begin{align}<br>f_{i, j} &amp; &#x3D; \sum_{k &#x3D; 1}^i \sum_{p &#x3D; i - k + 1}^i f_{k - 1, j - 1} \cdot f_{i-k, j} {p - 1 \choose i - k} \newline<br>&amp; &#x3D; \sum_{k &#x3D; 1}^i f_{k - 1, j - 1} \cdot f_{i-k, j} \sum_{p &#x3D; i - k + 1}^i{ p - 1 \choose i - k}<br>\end{align}<br>$$<br>后面这部分可以预处理+前缀和。</p><h2 id="AGC013D"><a href="#AGC013D" class="headerlink" title="AGC013D"></a>AGC013D</h2><p>神秘题。</p><p>一共有四种操作，如果以当前操作次数 $i$ 为 $x$ 轴，当前盒子中白球的数量 $j$ 为 $y$ 轴，作出图像，我们发现 $f_{i, j}$ 可以向 $f_{i + 1, j + 1}, f_{i + 1, j}, f_{i + 1, j - 1}$ 转移（注意 $f_{i + 1, j}$ 会被两种不同的操作转移到，这对应了两种生成序列，因此要统计两次）。进一步的，我们发现不同的图像对应的生成序列不同，相同的图像无论如何上下移动对应的生成序列一定都是相同的。解决办法是只需要统计最靠下的图像即可，换句话说就是图像中存在某个点 $(x, 0)$ 的图像就要统计在最终答案中。注意有一种向 $f_{i + 1, j}$ 转移的情况在转移过程中也会出现 $(x, 0)$ 的情况，不要忘记统计。</p><h2 id="P2159"><a href="#P2159" class="headerlink" title="P2159"></a>P2159</h2><p>直接求最多有 $k$ 对的方案是困难的，注意到 $k$ 不大，那么我们设 $f(k)$ 表示恰好有 $k$ 对满足条件的方案数，最终答案就是 $\sum_{i &#x3D; 0}^{k} f(i)$。对于 $f(i)$，我们现在有两种做法：</p><ol><li><p>二项式反演，设 $g(k)$ 表示钦定有 $k$ 对满足条件的方案数。如果将男女按身高降序排序，那么对于男生 $i$，有长度为 $num_i$ 的前缀女生满足选他可以使位置 $i$ 符合条件，并且 $num_i$ 是单调递增的。设 $dp_{i, j}$ 表示钦定前 $i$ 个人，有 $j$ 个位置满足条件。那么转移有：</p><ul><li>$dp_{i - 1, j} \times (num_i - j) \rightarrow dp_{i, j + 1}$；</li><li>$dp_{i - 1, j} \rightarrow dp_{i, j}$。</li></ul><p>同时 $dp_{n, i} \times (n - i)! &#x3D; g(i)$，这样就可以二项式反演。</p></li><li><p>设 $dp_{i, j}$ 表示前 $i$ 个人恰好有 $j$ 个位置满足条件，男女顺序排序，分类讨论转移。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>DP</tag>
      
      <tag>组合计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大步小步（BSGS）</title>
    <link href="/2024/10/01/BSGS/"/>
    <url>/2024/10/01/BSGS/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>BSGS 用于求解 $x$ 满足：<br>$$<br>a^x \equiv n \pmod p<br>$$<br>我们先来考虑特殊情况，当 $\gcd(a, p) &#x3D; 1$ 并假设一定有解。首先，根据欧拉定理，对于一个 $\varphi(p)$ 剩余系，存在且只存在一个 $x$ 使得上式成立。</p><h2 id="BSGS-大步小步"><a href="#BSGS-大步小步" class="headerlink" title="BSGS 大步小步"></a>BSGS 大步小步</h2><p>一般的方式是直接枚举，大步小步（BSGS, Baby step gaint step）提供了一种 $\mathcal{O}(\sqrt p)$ 时间负责度内解决的方法。设答案为 $k$，则 $k$ 可以表示成 $i m - j (j &lt; m)$ 的形式，则：<br>$$<br>\begin{align}<br>a^{im - j} &amp;\equiv n &amp;\pmod p \newline<br>a^{im} &amp;\equiv n \cdot a^j &amp;\pmod p \newline<br>\end{align}<br>$$<br>这个时候，我们逐一枚举 $j$，将结果 $n \cdot a^j$ 存到 Hash 表中；然后从小到大逐一枚举 $i$，如果 Hash 表内存在一个 $j$ 使得 $a^{im} \equiv n\cdot a^j$，直接输出 $im - j$ 一定是最小的正整数解，无解的情况则是将 $i$ 全部遍历之后不存在 $j$ 使得 $a^{im} \equiv n\cdot a^j$。以上做法的时间复杂度 $\mathcal{O}(\frac{p}{m} + m)$，根据均值不等式得到 $m &#x3D; \sqrt p$ 情况下最优。整体时间复杂度为 $\mathcal{O}(\sqrt p)$</p><h2 id="ExBSGS"><a href="#ExBSGS" class="headerlink" title="ExBSGS"></a>ExBSGS</h2><p>进一步的，我们考虑更一般的情况，此时没有 $\gcd(a, p) &#x3D; 1$，能否将他转换为 $\gcd(a, p) &#x3D; 1$ 的情况并使用一般的 BSGS 呢？设 $d &#x3D; \gcd(a, p)$，那么一定有：<br>$$<br>\frac{a}{d} \cdot a^{k  - 1} \equiv \frac{n}{d} \pmod {\frac{p}{d}}<br>$$<br>如果 $d \nmid n$ 则方程无解。这里 $\frac{a}{d}$ 就相当于常数了，但是此时仍然不能保证 $\gcd(a, p) &#x3D; 1$，很简单，重复以上操作 $m$ 次直到 $\gcd(a, p) &#x3D; 1$。</p><p>设 $D$ 是 $m$ 次操作之后所有 $d$ 的乘积，有：<br>$$<br>\frac{a^m}{D} \cdot a^{k - m} \equiv \frac{n}{D} \pmod {\frac{p}{D}}<br>$$<br>此时就可以 BSGS 做了。注意 $\frac{a^m}{D}$ 要当作常数传进 BSGS 函数里。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>分块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1602 题解</title>
    <link href="/2024/10/01/CF1602/"/>
    <url>/2024/10/01/CF1602/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1602-题解"><a href="#CF1602-题解" class="headerlink" title="CF1602 题解"></a>CF1602 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>不难发现字典序最小的 $a$ 就是串 $s$ 中字典序最小的字符。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>手玩可以发现不多于 $n$ 次的操作后序列将不会再变化。官方题解给出了更严谨的上界是 $\log n$ 次，直接暴力模拟即可。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>操作即为选择 $k$ 个数，将他们共有的二进制位为 $1$ 的减去。如果找出每一位 $1$ 在序列中出现的个数，那么最终答案就是它们的 $\gcd$ 的所有因数。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>可以发现，跳 $k$ 次后且滑落前所能到达的所有位置，一定是一个 $[l, n]$ 的连续区间。如果达不到的话只需要在前几次的跳跃中增加几次在 $n$ 的原地跳即可。</p><p>那么我们设 $c_i &#x3D; i  + b_i - a_{i + a_i}$，表示上次滑落前到达位置 $i$，至此能到达的位置的最小值。我们对 $c$ 做前缀最大值，同时记录最大值的位置，就可以得到上一次滑落前能到达的位置区间是 $[l, n]$，这次能到达的最小位置，记录进一个 <code>vector</code> 里，直到 $l &#x3D; 1$ 输出答案即可。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>容易证明将排序后的 $b$ 数组保持相对位置不变插入 $a$ 中更优。我们考虑分治，如果要将 $b_l \dots b_r$ 插入 $a$ 中的区间 $[L, R]$，取 $mid &#x3D; \left\lfloor\dfrac{l + r}{2}\right\rfloor$，考虑将 $b_{mid}$ 插入到 $a_j$ 之前对答案的影响：</p><ul><li>对全局：$\sum \limits_{i &#x3D; 1}^{j - 1} [a_i &gt; b_{mid}] + \sum \limits_{i &#x3D; j}^{n} [a_i &lt; b_{mid}]$</li><li>对区间 $[L, R]$：$\sum \limits_{i &#x3D; L}^{j - 1} [a_i &gt; b_{mid}] + \sum \limits_{i &#x3D; j}^{R} [a_i &lt; b_{mid}]$</li></ul><p>容易发现两式之差是定值，所以只要枚举 $j$ 使得对区间的贡献最小即可。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>观察性质，大胆猜测结论。按 $\max(a, s)$ 为第一关键字，$s$ 为第二关键字升序排序即可。<a href="https://www.luogu.com.cn/article/db3tx0l0">证明</a>（其实还挺容易感性理解的）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1794 题解</title>
    <link href="/2024/10/01/CF1794/"/>
    <url>/2024/10/01/CF1794/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1794-题解"><a href="#CF1794-题解" class="headerlink" title="CF1794 题解"></a>CF1794 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>将所给的字符串按长度降序排序，最前面的两个一定是最长的前缀与最长的后缀。如果原串是回文的，那么最长前缀一定等于最长后缀的反串。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>从前往后扫一遍，如果发现 $a_{i - 1} \mid a_i$，我们就将 $a_i \leftarrow a_i + 1$，此时一定有 $a_i \bmod a_{i - 1} &#x3D; 1$。但是当 $a_{i - 1} &#x3D; 1$ 时，通过改变 $a_i$ 一定无法满足条件，此时我们必需将 $a_{i - 1} \leftarrow a_{i - 1} + 1$，再对 $a_i$ 进行操作。不难发现每个数最多只会增加 $2$ 次，因此整个过程一定可以在 $2n$ 次操作内完成。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>$a$ 单调不降，容易发现一定是选择 $a$ 的某一个后缀可以使答案最优。那么我们对 $a$ 采取以下操作：$a_i \leftarrow \dfrac{a_i}{n - i + 1}$。此时对于一个后缀 $[p, n]$，他的答案一定为：</p><p>$$<br>\prod_{i &#x3D; p}^{n} a_i<br>$$</p><p>注意到修改后的 $a_i$ 是单调增的，一次如果我们发现在某一个 $i$ 满足 $a_i &lt; 1, a_{i + 1} \ge 1$，那么 $[i + 1, n]$ 一定是最优的。二分搜索即可。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>请看<a href="https://www.luogu.com.cn/article/ybnz55hr">题解</a>。</p><p>考虑多重组合：</p><p>根据题目，每个质数最多选一次（作质因数），我们假设质因数已经确定，还剩 $k$ 种数，每种数有 $r_k$ 个，考虑方案数。有：</p><p>$$<br>\begin{aligned}<br>  \begin{pmatrix}<br>    n\newline<br>    r_{1},r_{2},\dots,r_{k}\newline<br>  \end{pmatrix}<br>  &amp; &#x3D;<br>  \begin{pmatrix}<br>    n\newline<br>    r_{1}\newline<br>  \end{pmatrix}<br>+<br>  \begin{pmatrix}<br>    n-r_{1}\newline<br>    r_{2}\newline<br>  \end{pmatrix}<br>+<br>\cdots<br>+<br>  \begin{pmatrix}<br>    n-(r_{1}+r_{2}+\dots+r_{k-1})\newline<br>    r_k\newline<br>  \end{pmatrix}<br>\newline &amp;&#x3D;<br>  \frac{n!}{r_{1}!(n-r_{1})}<br>  \times<br>  \frac{(n-r_{1})!}{r_{2}!(n-(r_{1}+r_{2}))}<br>  \times<br>\cdots<br>  \times<br>  \frac{(n-(r_{1}+r_{2}+\dots+r_{k-1}))!}{r_{k}!}<br>\newline &amp;&#x3D;<br>  \frac{n!}{r_{1}!+r_{2}!+\dots+r_{k}!}<br>\end{aligned}<br>$$</p><p>$n$ 比较大，我们不能直接暴力算。</p><p>定义：$dp_{i}$ 表示目前选了 $i$ 个数作质因数（其他遍历过的数全作指数）时的方案数。</p><p>线性筛求出所有质数，将数组 $a$ 中的数去重并记录个数，注意到 $mod&#x3D;998244353$，考虑用乘法逆元代替除法，这样我们可以在转移的同时计算将剩下的数当作指数分配给 $n$ 个位置的方案数（可以将 $dp_{0}$ 初始化为 $n!$ 或在最后将答案乘 $n!$）。</p><ul><li>如果当前数不为质数：$dp_{j}&#x3D;(dp_{j} \times ny_{sum_{i}})$</li><li>如果当前数为质数：$dp_{j}&#x3D;(dp_{j} \times ny_{sum_{i}})+(dp_{j-1} \times ny_{sum_{i}-1})$</li></ul><p>通过 NTT 可以做到 $\mathcal{O}(n \log^2 n)$，我不会。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>我们不考虑多出来的一个点。如果以 $u$ 为根，点填的权值一定为点的深度。此时我们可以考虑一个哈希：</p><p>$$<br>H&#x3D;cnt_1+cnt_2\times base+cnt_3\times base^2…..cnt_{n-1}\times base^{n-2} \bmod p<br>$$</p><p>注意到这个哈希函数是可以进行换根的。设 $fa$ 为 $u$ 的根，v 为 $u$ 的儿子。 ：</p><ul><li>当我们要去到 $v$ 的时候，$H_u&#x3D;H_u-H_v\times base$。</li><li>当我们要回到 $u$ 的时候，$H_u&#x3D;H_u+H_v\times base$。</li><li>当我们刚到达 $u$ 的时候，$H_u&#x3D;H_u+H_{fa}\times base$。</li><li>当我们要离开 $u$ 的时候，$H_u&#x3D;H_u-H_{fa}\times base$。</li></ul><p>接下来我们考虑多出来的一个点怎么办，注意到它只会影响 $base$ 的一个幂次，直接将两者的哈希值相减判断即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1918 题解</title>
    <link href="/2024/10/01/CF1918/"/>
    <url>/2024/10/01/CF1918/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1918-题解"><a href="#CF1918-题解" class="headerlink" title="CF1918 题解"></a>CF1918 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>注意到只放横向的砖块即可，每横行最多可以放 $\left \lfloor \frac{m}{2} \right \rfloor$ 块砖，一共 $n$ 行，答案 $\left \lfloor \frac{m}{2} \right \rfloor \cdot n$。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>注意到如果 $a, b, c, d$ 分别是 $A, B$ 中位置为 $i, j$ 的数字：</p><p>$$<br>a \quad xa, xb \quad b \quad ya, yb \newline<br>c \quad xc, xd \quad d \quad yc, yd<br>$$</p><p>其中，$x_$ 表示 $\left(i, j\right)$ 中 $&gt; _$ 的数的个数，$y_$ 表示 $\left(j, n\right]$ 中 $&gt; _$ 的数的个数。</p><p>那么设交换之前与 $i, j$ 位置有关的逆序对的个数为 $w$，交换之后与 $i, j$ 位置有关的逆序对的个数为 $w’$，有：</p><p>$$<br>w &#x3D; \left(xa + ya + yb\right) + \left(xc + yc + yd\right) \newline<br>w’ &#x3D; \left(xb + yb + ya\right) + \left(xd + yd + yc\right)<br>$$</p><p>注意到：</p><p>$$<br>w’ - w &#x3D; \left(xb - xa\right) + \left(xd - xc\right)<br>$$</p><p>每进行一次交换对答案的贡献为 $w’ - w$。为了使最终构造的数列最优，一定有</p><p>$$<br>\forall i, j \in \left[1, n\right],w’ - w \geq 0<br>$$</p><p>注意到如果 $i,j$ 之间的距离为 $len$，则 $xa, xb, xc, xd \leq len$。若 $A$ 有序，则 $xb &#x3D; len, xa &#x3D; 0$，此时 $w’ - w \geq 0$，符合最优条件。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><del>直接贪贪完了</del></p><p>注意到 $ans$ 最小即为异或之后 $a, b$ 最接近。那么从最高位贪心，若 $a, b$ 同一位上数字不同且较大一方该位为 $1$，异或上 $1$ 之后可以使答案更优。</p><p><del>所以直接贪贪完了</del></p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>二分答案 + DP</p><p>如果 $res \leq val$，则一定满足：</p><ul><li>相邻两个断点之间子段和 $\leq val$</li><li>所选的各点点权和 $\leq val$</li></ul><p>设 $f_i$ 表示考虑前 $i$ 个位置，选了第 $i$ 个位置，且相邻两个断点之间子段和 $\leq val$ 的最小价值，得到转移式：</p><p>$$<br>f_i &#x3D; a_i + \min_{s_{i - 1} - s_j \leq val} f_j<br>$$</p><p>可以单调队列优化。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>注意到：传送一定在某个叶子结点。</p><p>注意到：某个子树内如果发生了传送，那么传送点一定在该子树内最深的节点。</p><p>注意到：如果我们按顺序遍历子树，那么传送之后一定会再次回到某个子树的根节点。</p><p>注意到：如果不进行传送，那么 $ans &#x3D; 2n - 1$。</p><p>注意到：设以 $i$ 为根的子树内最深的点为 $b_i$，那么直接返回的代价为 $dep_{b_i} - dep_i + 1$。</p><p>注意到：如果传送，代价为 $dep_i - 1$。</p><p>注意到：如果传送，最终答案就会减小 $dep_{b_i} - 2 \cdot dep_i + 2$。</p><p>注意到：排个序取前 $k$ 小的直接做做完了。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><a href="https://www.luogu.com.cn/article/qr4lea2l">这篇题解</a>写挺好的，看这个吧，不写了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1805 题解</title>
    <link href="/2024/10/01/CF1805/"/>
    <url>/2024/10/01/CF1805/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1805-题解"><a href="#CF1805-题解" class="headerlink" title="CF1805 题解"></a>CF1805 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>按位贪心，$x$ 里每一位的 $1$ 会使 $b$ 中的 $0,1$ 个数的奇偶性取反，使得每一位 $1$ 的个数为偶数即可。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>结论：将最小的字符提到最前，若有相同的取最后的。</p><p>接下来我们来证明以上结论：</p><blockquote><p>字符串的第一位一定是最小的可以使答案最优。第一条得证。</p><p>考虑我们有两个可选的位置 $l, r \mid a[l] &#x3D; a[r] &#x3D; \min{a} &#x3D; c$。如果选择 $l$，答案为 $c + [1, l -1] + [l + 1, r - 1] + c + [r + 1, n]$；如果选择 $r$，答案为 $c + [1, l - 1] + c + [l + 1, r - 1] + [r + 1, n]$。</p><p>注意到一定有 $c + [l + 1, r - 1] &lt; [l + 1, r - 1] + c$，因此我们证明了对于任意两个最小值一定是选最小的更优，可以推广到整个串的情况。</p></blockquote><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>考虑到大家都上过初中，我们直接计算 + 二分找 $k$ 即可。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>有以下结论：</p><ol><li>若点 $x$ 到最远的点的距离 $&lt; k$，说明 $x$ 自成一个联通块；</li><li>若点 $x$ 到直径某一个端点的距离 $\ge k$，则 $x$ 与端点共联通块；</li><li>因此，每一个点要么单独成联通块，要么与直径端点共联通块；</li></ol><p>那么我们直接找出直径，开桶统计最远距离即可。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p><a href="https://www.luogu.com.cn/article/2mx8b4i3">https://www.luogu.com.cn/article/2mx8b4i3</a></p><blockquote><p>考虑对每个数值做：</p><ul><li>这个数值只出现了一次：没用。</li><li>出现了至少三次：这个数值对整棵树所有边都有贡献。证明割了一条边后两棵肯定是一棵一个，另一棵两个。</li><li>正好两次：对于这两个点之间的边没贡献，其他都有贡献。</li></ul><p>考虑直接写个树剖跑这个东西。可以套线段树区间赋值。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1935题解</title>
    <link href="/2024/10/01/CF1935/"/>
    <url>/2024/10/01/CF1935/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1935-题解"><a href="#CF1935-题解" class="headerlink" title="CF1935 题解"></a>CF1935 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>注意到操作 2 一定只会进行一次，因为如果进行两次一定会使原串的字典序更大。那么还可以发现当且仅当 $s$ 反转之后的串 $t$ 满足 $t &lt; s$ 才会进行操作 2。</p><p>结合 $n$ 一定为偶数。当 $t &lt; s$ 时输出 $t + s$，否则直接输出 $s$ 即可。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>对于两个 $\operatorname{mex}$ 值相同的区间，两者合并之后的区间的 $\operatorname{mex}$ 值一定与两者相同，因此我们可以只将原序列分成两部分考虑。</p><p>那么我们可以做一个前缀&#x2F;后缀 $\operatorname{mex}$，枚举中间断点使得两部分 $\operatorname{mex}$ 相同即可。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>注意到原式一定是将二元对以 $b$ 为关键字排序答案最优，那么有：</p><p>$$<br>\min \left { \sum_{i &#x3D; 1}^{k - 1}|b_i - b_{i + 1}| \right } &#x3D; b_{\max} - b_{\min}<br>$$</p><p>因此我们考虑将原数组以 $b$ 为关键字排序，对于每一个左端点 $l$ 维护一个大根堆，如果不满足 $sum + b_r - b_l \leq L$ 就弹出堆顶，答案即为堆的大小。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>容斥，答案为数对 $(x,y)$ 的数量减去 $y+x,y-x$ 至少有一个在 $s$ 里的数量，加上 $y+x,y-x$ 都在 $s$ 里的数量。</p><p>第一部分是 $\frac{(c+1)(c+2)}{2}$，第二部分是 $\sum \limits_{i&#x3D;1}^n (n-s_i+1)+(\left \lfloor \frac{s_i}{2} \right \rfloor +1)$，其中前面是是差为 $s$，后面是和为 $s$，注意要保证 $x \le y$。</p><blockquote><p>考虑第三部分的计数，枚举 $x+y &#x3D; s_i$，相当于问前面有多少 $j$ 满足 $y+x&#x3D;s_i,y-x&#x3D;s_j(j \le i)$ 有解且解合法（$0 \le x \le y \le c$）。通过初中数学知识不难解得 $y &#x3D; \frac{s_i+s_j}{2},x &#x3D; s_i - \frac{s_i+s_j}{2}$。首先只有 $s_i \equiv s_j \pmod 2$ 时 $x,y$ 为整数，又注意到由于 $s_j \le s_i$，因此解出的 $x,y$ 一定满足条件，即只需要统计对于 $s_i$ 前面有多少 $s_j$ 与之奇偶性相同，前缀和即可。</p></blockquote><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote><p>首先我们对于每一对 $(x_i,y_i)$，去除它们二进制下最长公共前缀并直接算入答案 $ans$，此时一定满足 $x_i &lt; y_i$ 且最高位不同。考虑对于某一位 $j$，考虑区间内有多少 $y_i$ 满足 $y_i$ 的第 $j$ 位是 $1$，加上 $ans$ 的第 $j$ 位是否是 $1$ 后假设有 $c$ 个：</p><ul><li>$c \ge 2$：因为我们已经保证 $x_i &lt; y_i$，所以一定可以一个位置令 $a_i &#x3D; 2^j$，一个位置令 $a_i &#x3D; 2^j-1$，或起来后 $j$ 及更低的二进制位都已经是 $1$，不需要再往下考虑。</li><li>$c &#x3D; 1$：此时我们一定填 $1$，这一位对答案产生贡献。</li><li>$c &#x3D; 0$：这一位没有意义。</li></ul><p>你也可以通过以上流程发现，在去除最长公共前缀后 $x_i$ 就已经没有意义，因为当 $c \ge 2$ 时我们直接得到答案，$c&#x3D;  1$ 时只关心能否在某一位填 $1$，而这个与 $x_i$ 无关。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF2032 题解</title>
    <link href="/2024/10/01/CF2032/"/>
    <url>/2024/10/01/CF2032/</url>
    
    <content type="html"><![CDATA[<h1 id="CF2032-题解"><a href="#CF2032-题解" class="headerlink" title="CF2032 题解"></a>CF2032 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>设打开了 $k$ 个开关：</p><ul><li>最小：两个同种状态的开关尽量连接同一盏灯，那么答案就为 $k \bmod 2$。</li><li>最多：两个不同种状态的开关尽量连接同一盏灯，那么答案就为 $n - \left|k - n\right|$。</li></ul><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>可以证明如果满足 $k &#x3D; 1 \vee k &#x3D; n$，那么一定无解。我们以最简单的情况将序列分成 $3$ 段，考虑 $k$ 的奇偶性：</p><ul><li>$k \equiv 0 \pmod 2$ 可以分成 $[1, k - 1] \ [k, k] \ [k + 1, n]$。</li><li>$k \equiv 1 \pmod 2$ 可以分成 $[1, k - 2] \ [k - 1, k + 1] \ [k + 2, n]$。</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>如果满足题面要求，一定有：<br>$$<br>a_{\max} &lt; a_{\min} + a_{\min + 1}<br>$$<br>对 $a$ 排序，枚举一个最大值，二分出满足要求的最小值，答案即为 $n - \max + \min - 1$，时间复杂度 $\mathcal{O}(n \log n)$。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>考虑从 $n - 1$ 向 $1$ 询问推断出树的形状。那么第一次询问 $n - 1$ 和 $n - 2$，通过题面我们发现 $n - 1$ 的父亲的编号一定小于等于 $n - 2$，那么从 $n - 2$ 逐一向更小询问，一旦发现答案为 $1$，可以证明此时编号更小的一定是编号更大者的父节点。接下来我们把两个数都 $-1$，继续询问直到某一者为 $0$。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>考虑操作之后序列值的变化 $a_i \leftarrow a_i + 2 c_i + c_{i - 1} + c_{i + 1}$。那么有：<br>$$<br>a_i + 2 c_i + c_{i - 1} + c_{i + 1} &#x3D; a_{i + 1} + 2 c_{i + 1} + c_i + c_{i + 2} \newline<br>(c_i + c_{i - 1}) - (c_{i + 1} + c_{i + 2}) &#x3D; a_{i + 1} - a_i<br>$$<br>设 $b_i &#x3D; c_i + c{i - 1}$，则 $b_{i + 1} &#x3D; b_i + a_i - a_{i + 1}$。$b$ 是可求的，那么也就可以推出 $c$。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>Nim 游戏是 <strong>9 级知识点</strong>，不会。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1998 题解</title>
    <link href="/2024/10/01/CF1998/"/>
    <url>/2024/10/01/CF1998/</url>
    
    <content type="html"><![CDATA[<h1 id="CF1998-题解"><a href="#CF1998-题解" class="headerlink" title="CF1998 题解"></a>CF1998 题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>分两种情况讨论：</p><ol><li>$2 : \mid : n$：把每个点对称的放在中心点两侧</li><li>$2 : \nmid : n$：同上，多出来的一个点放在中心点上</li></ol><p>做完了。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>注意到 $p$ 和 $q$ 都是排列，那么如果我们将 $p$ 右移一个单位，多出来的部分补到第一个，那么如果设 $p,q$ 的区间和分别是 $psum,qsum$：<br>$$<br>qsum_{l, r} &#x3D; psum_{l, r} + p_{l - 1} - p_{r + 1}<br>$$<br>显然 $p_{l - 1} \neq p_{r + 1}$，一次对于任意非 $[1, n]$ 的区间，对答案都没有贡献，最终答案取得最小 $1$。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>设题目中的 $a_i + \text{median}(c_i)$ 为 $f_i$。</p><p>首先有两个结论：</p><ul><li>若所有 $b_i$ 均为 $0$，由于不考虑增加的数量 $k$，当 $a_i$ 最大时答案取最大为 $f_i$。</li><li>若所有 $b_i$ 均为 $1$，当 $a_i$ 最大时答案取最大为 $f_i+k$。</li></ul><blockquote><p>证明：</p><p>先考虑当 $b_i$ 均为 $0$ 的情况，默认 $a_i$ 已按递增排序。</p><p>令删除最大的数后的中位数为 $mid$。</p><p>若 $a_i &gt; mid$，则 $i$ 的坐标 $&gt; \lfloor \frac{n}{2}\rfloor$，中位数坐标为 $\lfloor \frac{n}{2}\rfloor$。</p><p>若 $a_i \le mid$，则 $i$ 的坐标 $\le \lfloor \frac{n}{2}\rfloor$，中位数坐标为 $\lfloor \frac{n}{2}\rfloor + 1$。</p><p>第一种情况最优为 $a_n + a_{\lfloor \frac{n}{2}\rfloor}$，第二种情况最优为 $a_{\lfloor \frac{n}{2}\rfloor + 1} + a_{\lfloor \frac{n}{2}\rfloor}$。</p><p>显然前者大于等于后者，所以最优策略即为删一个最大的 $a_i$。</p><p>第一条结论得证。</p><p>第二条结论就简单了，如果把 $k$ 个贡献加到 $a_i$ 上的话可以获得实打实的 $k$ 个贡献，而加到其他数上，首先一定不会超过 $k$ 的贡献，其次由于中位数的变动，贡献很可能小于 $k$。</p><p>第二条结论得证。</p></blockquote><p>现在让我们考虑既有 $0$ 又有 $1$ 的情况。</p><p>不难发现当最大的 $a_i$ 对应的 $b_i$ 为 $1$ 时，答案即为 $f_i + k$。</p><p>否则首先一种情况是选定 $a_i$，并用 $k$ 次操作最大化剩下部分的中位数，这个二分答案然后按 $a_i$ 从大往小判断 $k$ 次操作内，是否存在至少 $\lfloor\frac{n + 1}{2}\rfloor$ 个数 $\ge mid$。另一种情况是找到 $b_j &#x3D; 1$ 时最大的 $a_j$，这种情况的最优答案为 $f_j + k$。两种情况取个 $\max$ 即可。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>注意到如果 B 的起点为 $s$，起点在 $s$ 以后的桥都是不用考虑的，因为：</p><ol><li>如果 B 还没有走到某个点，E 却已经走到了，E 就一定可以比 B 先到达终点，无论有没有特殊的桥</li><li>如果 B 走到某个点，那么这个点上所有的桥都不能用了，不用考虑</li></ol><p>所以如果我们每一次枚举 $s$，维护每个点到起点的最短距离，当存在某个点 $v$ 使得 $n - v + dis[v] \leq n - s$ 时，E 就可以比 B 先到，反之。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>建议 E1 + E2 一起食用。</p><p>不难发现对于一个区间内的最大值，他是一定可以留到整个区间都消没的时候的。通过这个性质让我们想到可以通过分治做这道题。</p><p>以上是可以通过 E1 的，对于 E2 呢？</p><p>考虑到分治的过程其实就是一棵笛卡尔树，再利用一些性质，就做完了。</p><p>具体细节：<a href="https://www.luogu.com.cn/article/q68h5omh">https://www.luogu.com.cn/article/q68h5omh</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF2005 题解</title>
    <link href="/2024/10/01/CF2005/"/>
    <url>/2024/10/01/CF2005/</url>
    
    <content type="html"><![CDATA[<h1 id="CF2005-题解"><a href="#CF2005-题解" class="headerlink" title="CF2005 题解"></a>CF2005 题解</h1><p>主观评分： B &lt; A &lt; C &lt; E &lt; D</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>注意到有一些贡献是无法避免的：每个字母都会对回文串数量产生 $1$ 的贡献，同时，连续的几个相同的字符也会对答案产生贡献。</p><p>考虑我们现在有两个相同的字符，在序列上的距离为 $len$，那么至少会有 $len$ 的贡献。但是如果我们将任意两个相同的字符都放到一块就可以使回文子序列最少。</p><p>那么对于 $m$ 个相同的字符，他们的贡献是 $2^m$，因此我们使得每一种相同的字符数量都最小，每一种相同的字符数量都连续，这样答案一定最优。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>对于每一个 $a$，只要考虑左右两侧离他最近的老师即可，$a$ 一定是跑到两者的中位数最优，因此可以用排序后二分搜索，复杂度 $\mathcal{O}(m \log q)$，实现时注意边界。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>我们设 $f_{i, j}$ 表示前 $i$ 个串，最后选到的字符是 $j$，的最大答案。那么我们枚举一个 $k$，枚举一个字符属于 <code>naerk</code> 就让 <code>ans --</code>，如果枚举到了字符 <code>k</code> 就让答案 $+4$，这样最后统计的答案就是对的，每考虑完一个字串对 $f$ 取 max，最终答案为 $\max(f_{n, 0}, f_{n, 1}, f_{n, 2}, f_{n, 3}, f_{n, 4})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> T, n, m, f[<span class="hljs-number">5</span>], g[<span class="hljs-number">5</span>];<br>string s, t = <span class="hljs-string">&quot;narek&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br> cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br> cin &gt;&gt; T;<br> <span class="hljs-keyword">while</span> (T --) &#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x80</span>, <span class="hljs-built_in">sizeof</span>(f));<br>  f[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (n --) &#123;<br>   cin &gt;&gt; s;<br>   <span class="hljs-built_in">memcpy</span>(g, f, <span class="hljs-built_in">sizeof</span>(g));<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>    <span class="hljs-type">int</span> k = i, tmp = f[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>     <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">find</span>(c) == t.npos) <span class="hljs-keyword">continue</span>;<br>     tmp --;<br>     <span class="hljs-keyword">if</span> (t[(k + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>] == c)<br>      tmp += <span class="hljs-number">10</span> * (((k += <span class="hljs-number">1</span>) %= <span class="hljs-number">5</span>) == <span class="hljs-number">4</span>);<br>    &#125;<br>    g[k] = <span class="hljs-built_in">max</span>(g[k], tmp);<br>   &#125;<br>   <span class="hljs-built_in">memcpy</span>(f, g, <span class="hljs-built_in">sizeof</span>(f));<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-built_in">max</span>(&#123;f[<span class="hljs-number">0</span>], f[<span class="hljs-number">1</span>], f[<span class="hljs-number">2</span>], f[<span class="hljs-number">3</span>], f[<span class="hljs-number">4</span>]&#125;) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>我们设 $f_{k, i, j}$ 表示选了 $a$ 中的第 $k$ 位，现在考虑 $(i + 1, j + 1)$ 和 $(n, m)$ 处的子矩形，是否必胜。那么注意到 $f_{k}$ 的取值一定形如：<br>$$<br>\begin{pmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\newline<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\newline<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\newline<br>1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\newline<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\newline<br>\end{pmatrix}<br>$$<br>这样阶梯状的。因为 $f_{i, j, k} &#x3D; 1$ 当且仅当：</p><ul><li>$\exists b_{i, j} &#x3D; k, (k &#x3D; l) \vee (i &#x3D; n) \vee (j &#x3D; m)$，也就是说后手已经没的选了</li><li>$(i + 1, j + 1)$ 和 $(n, m)$ 处的子矩形里有可选的的必胜位</li></ul><p>那么我们设 $mx_{k, i}$ 表示第 $i$ 行最靠右的字符 $k$ 的位置，$g_{k, i}$ 表示第 $i$ 行最靠右的 $f_{k,i,j}$ 的 $j$。</p><p>还有一个结论：</p><p>如果某个数字在 $a$ 中出现了多次，设第二次出现的位置为 $t$，那么将 $a$ 中 $t$ 及以后的数字全部删去（令 $l \leftarrow t−1$）不影响答案。</p><blockquote><p>假设当前操作者面对的子矩形中有两个位置 $(x,y),(u,v)$ 满足 $x &gt; u, y &gt; v,b_{x,y} &#x3D; b_{u,v} &#x3D; a_k$，因为 $f_{x+1,y+1,k+1}&#x3D;1⇒f{u+1,v+1,k+1}&#x3D;1$，所以选择 $(x,y)$ 能够最大化对手进必败点的情况数，不劣于选择 $(u,v)$。因此两个人选择的 $(i,j)$ 都满足 $\not \exists x &gt; i, y &gt; j : b_{x,y} &#x3D; b_{i,j}$，而子矩形在往右下方收缩，在 $a$ 中第二次碰到 $b_{i,j}$ 时必然无法操作从而失败，这等价于序列在此终止。</p></blockquote><p>这样直接在 $g$ 上转移即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF2006 题解</title>
    <link href="/2024/10/01/CF2006/"/>
    <url>/2024/10/01/CF2006/</url>
    
    <content type="html"><![CDATA[<h1 id="CF2006-题解"><a href="#CF2006-题解" class="headerlink" title="CF2006 题解"></a>CF2006 题解</h1><p><a href="https://codeforces.com/contest/2006/attachments/download/26936/tutorial.pdf">官方中文题解</a></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>注意到 3 个数中一定不会出现两个偶数，那么就一定会有两个奇数，设区间中奇数的个数为 $cnt$，那么答案上界一定为 $\left \lfloor \frac{cnt}{2} \right \rfloor$。</p><p>xxxxxxxxxx103 1#include &lt;bits&#x2F;stdc++.h&gt;2​3using namespace std;4typedef long long ll;5​6const int MAXN &#x3D; 5010, MAXM &#x3D; 1e6 + 10;7int n, m, cnt, ans, fa[MAXN], from[MAXN], sec[MAXN], rt[MAXN];8bitset<MAXN> vis;9double E, dis[MAXN];10​11struct Edge {12    int v;13    double w;14    int id;15​16    Edge() {}17    Edge(int V, double W, int Id) : v(V), w(W), id(Id) {}18};19vector<Edge> g[MAXN], h[MAXN];20​21struct Node {22    int lc, rc;23    double sum;24    int dep, fa;25} t[MAXM];26int tot;27​28int nw(int f, double val) {29    t[++tot] &#x3D; {0, 0, val, 0, f};30    return tot;31}32​33int merge(int x, int y) {34    if (!x || !y) return x | y;35    if (t[x].sum &gt; t[y].sum) swap(x, y);36    int p &#x3D; ++tot;37    t[p] &#x3D; t[x];38    t[p].rc &#x3D; merge(t[p].rc, y);39    if (t[t[p].lc].dep &lt; t[t[p].rc].dep) swap(t[p].lc, t[p].rc);40    t[p].dep &#x3D; t[t[p].rc].dep + 1;41    return p;42}43​44void dijkstra() {45    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) dis[i] &#x3D; INFINITY;46    priority_queue&lt;pair&lt;double, int&gt;, vector&lt;pair&lt;double, int&gt;&gt;, greater&lt;&gt;&gt; pq;47    pq.emplace(dis[n] &#x3D; 0, n);48    while (!pq.empty()) {49        auto [c, u] &#x3D; pq.top();50        pq.pop();51        if (vis[u]) continue;52        vis[u] &#x3D; 1;53        for (auto [v, w, id] : h[u]) {54            if (dis[v] &gt; c + w) pq.emplace(dis[v] &#x3D; c + w, v), from[v] &#x3D; id, fa[v] &#x3D; u;55        }56    }57}58​59signed main() {60    ios::sync_with_stdio(0);61    cin.tie(0), cout.tie(0);62​63    cin &gt;&gt; n &gt;&gt; m &gt;&gt; E;64    for (int i &#x3D; 1; i &lt;&#x3D; m; i++) {65        static int u, v;66        static double w;67        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;68        if (u &#x3D;&#x3D; n) {69            i–, m–;70            continue;71        }72        g[u].emplace_back(v, w, ++cnt);73        h[v].emplace_back(u, w, cnt);74    }75    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) sec[i] &#x3D; i;76    dijkstra();77    sort(sec + 1, sec + 1 + n, [](int a, int b) -&gt; bool { return dis[a] &lt; dis[b]; });78    t[0].dep &#x3D; -1;79​80    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {81        int u &#x3D; sec[i];82        for (auto [v, w, id] : g[u]) {83            if (id &#x3D;&#x3D; from[u]) continue;84            rt[u] &#x3D; merge(rt[u], nw(v, w - dis[u] + dis[v]));85        }86        rt[u] &#x3D; merge(rt[u], rt[fa[u]]);87    }88​89    E -&#x3D; dis[1], ans &#x3D; 1;90    priority_queue&lt;pair&lt;double, int&gt;, vector&lt;pair&lt;double, int&gt;&gt;, greater&lt;&gt;&gt; pq;91    pq.emplace(t[rt[1]].sum, rt[1]);92    while (!pq.empty()) {93        auto [c, v] &#x3D; pq.top();94        pq.pop();95        if (E &lt; c + dis[1]) return cout &lt;&lt; ans &lt;&lt; ‘\n’, 0;96        E -&#x3D; c + dis[1], ans++;97        if (t[v].lc) pq.emplace(c - t[v].sum + t[t[v].lc].sum, t[v].lc);98        if (t[v].rc) pq.emplace(c - t[v].sum + t[t[v].rc].sum, t[v].rc);99        if (rt[t[v].fa]) pq.emplace(c + t[rt[t[v].fa]].sum, rt[t[v].fa]);100    }101​102    return cout &lt;&lt; ans &lt;&lt; ‘\n’, 0;103}cpp</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>先遍历一遍找到最大值，如果最大值在每一次修改的区间内，就对最大值作相应的修改。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>考虑序列中的一个数 $c$，如果最后的结果为 $d$，那么相当于对 $ax + by &#x3D; d - c$ 求一组可行解。根据裴蜀定理，有 $\gcd(a, b) \mid (d - c)$。</p><p>就相当于答案最大为 $\gcd(a, b)$，转化成在 $\bmod \gcd(a, b)$ 的剩余系中考虑该问题。那么可以将序列中每一个数字都 $\bmod \gcd(a, b)$，前后扫一遍找最小值即可。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>可以将 01 串看作海拔的高低，01 指上山，10 指下山，那么最终答案为零一定是串的两端海拔相平，也就是数字相同。</p><p>也就是说，A 希望根的数字与叶子数字尽量不同，B 希望根的数字与叶子数字尽量相同，简单分类讨论即可。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>树按 dfs 序标号，所以最终的 $n$ 条路径中，每条边恰好被经过两次。注意到最终考虑的答案也会是的每条边经过两次。</p><p>那么我们需要对一条路径找到一些信息，只与剩余的 $w$ 和经过的所有边有关，可以快速维护这条路径的长度的上限。注意到如果这条路径上还有边没有确定，那么把 $w$ 全部放到未确定的边上最优；否则这条路径的长度已经确定了。那么需要维护尚未确定值的边数和已经确定值的边的长度和。</p><p>那么答案的组成部分是，确定的路径的长度，没有完全确定的路径的确定部分的长度。对于每条没有完全确定的路径，会额外贡献一个 $w$。直接维护就行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lucas 定理</title>
    <link href="/2024/10/01/Lucas/"/>
    <url>/2024/10/01/Lucas/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Lucas 定理用于求解大组合数取模问题。一般的组合数可以 $\mathcal{O}(n)$ 预处理阶乘 + $\mathcal{O}(1)$ 计算，牵扯到取模会再带一个 $\log$；或者 $O(n^2)$ 全部预处理。但是他们都需要预处理，如果要求的组合数很大，无法预处理，Lucas 定理提供了一种仅需预处理模数范围内的组合数的做法。</p><h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>$$<br>{n \choose m} \equiv<br>\begin{pmatrix}<br>{\left\lfloor \frac{n}{p} \right\rfloor} \newline<br>{\left\lfloor \frac{m}{p} \right\rfloor}<br>\end{pmatrix}<br>\cdot<br>\begin{pmatrix}<br>n \bmod p \newline<br>m \bmod p<br>\end{pmatrix}<br>\pmod {p}<br>$$</p><p>左侧的部分可以继续递归使用 Lucas 求解，右侧的 $n \bmod p$ 和 $m \bmod p$ 一定小于 $p$，可以预处理。时间复杂度 $\mathcal{O}(f(n) + g(n) \log n)$，其中 $f(n)$ 表示预处理组合数的复杂度，$g(n)$ 表示单次处理组合数的时间复杂度。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>考虑 ${p \choose n} \bmod p$，拆开组合数得 $\frac{p!}{n!(p - n)!}$，分子一定含有一个质因子 $p$，考虑分母，当 $n &#x3D; 0$ 或 $n &#x3D; p$ 时分母中含有质因子 $p$，此时 $p \choose 0$ 和 $p \choose p$ 都为 $1$；其余情况都为 $0$。因此有：</p><p>$$<br>{p \choose n} \bmod p &#x3D; [n &#x3D; 0 \vee n &#x3D; p]<br>$$</p><p>进而，有：</p><p>$$<br>\begin{align}<br>(a + b) ^ p &amp; \equiv \sum_{i &#x3D; 0}^p {p \choose i} a^i b^{p - i}\newline<br>&amp; \equiv \sum_{i &#x3D; 0}^p [i &#x3D; 0 \vee i &#x3D; p] a^i b^{p - i}\newline<br>&amp; \equiv a^p + b^p \pmod p<br>\end{align}<br>$$</p><p>考虑二项式 $(1 + x)^n \bmod p$，那么 $n \choose m$ 就是在求 $x^m$ 的系数：</p><p>$$<br>\begin{align}<br>(1 + x)^n &amp;\equiv (1 + x)^{p\lfloor n&#x2F;p \rfloor} (1 + x)^{n \bmod p}\newline<br>&amp;\equiv (1 + x^p)^{\lfloor n&#x2F;p \rfloor} (1 + x)^{n \bmod p}\newline<br>&amp;\equiv \sum_{i &#x3D; 0}^{\lfloor n&#x2F;p \rfloor} {\lfloor n&#x2F;p \rfloor \choose i} x^{pi}\cdot \sum_{i &#x3D; 0}^{n \bmod p} {n \bmod p \choose i} x^i\newline<br>&amp;\equiv \sum_{i &#x3D; 0}^{\left\lfloor n&#x2F;p \right\rfloor}\sum_{j &#x3D; 0}^{n \bmod p} { \left\lfloor n&#x2F;p \right\rfloor \choose j} { {n \bmod p} \choose i} x^{pj + i}\newline<br>&amp;\equiv \sum_{i &#x3D; 0}^{n} {n \choose i} x^i &amp; \pmod p<br>\end{align}<br>$$</p><p>我们发现，由于 $n \bmod p \lt p$ 且 $ip &gt; p$，则任何一个 $x^m$ 的系数都是由左右两侧唯一的一组 $m \bmod p$，和 $\lfloor m &#x2F;p \rfloor$ 处的系数相乘得到的，Lucas 定理得证。</p><h2 id="扩展-Lucas-定理"><a href="#扩展-Lucas-定理" class="headerlink" title="扩展 Lucas 定理"></a>扩展 Lucas 定理</h2><p>没写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2024 游记</title>
    <link href="/2024/10/01/NOIP2024/"/>
    <url>/2024/10/01/NOIP2024/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP2024-游记"><a href="#NOIP2024-游记" class="headerlink" title="NOIP2024 游记"></a>NOIP2024 游记</h1><h2 id="6-40"><a href="#6-40" class="headerlink" title="6:40"></a>6:40</h2><p>起床。</p><p>本来是可以住在连大附近的宾馆的，但是我觉得早起半个小时吹吹风至少能避免考试犯困。</p><p>Upd: 好像也没啥，毕竟还得坐车。</p><h2 id="7-50"><a href="#7-50" class="headerlink" title="7:50"></a>7:50</h2><p>下车，遇到了 <a href="https://www.luogu.com.cn/user/403084">spark_minous</a>，然后去找 <a href="https://www.luogu.com.cn/user/1147314">snowycat1234</a>。发现他们正在进考场的第一部分队伍里，看了一眼自己考号发现竟然还能站在这里（我站在前 40，真的假的），想必一定是因为 LN 弱弱省。</p><h2 id="8-10"><a href="#8-10" class="headerlink" title="8:10"></a>8:10</h2><p>进考场，发现了【数据删除】曾说过的传统艺能：女厕改『考生专用』。</p><h2 id="8-20"><a href="#8-20" class="headerlink" title="8:20"></a>8:20</h2><p>敲 <code>.vimrc</code>，考前没背，差点忘了。</p><h2 id="8-30"><a href="#8-30" class="headerlink" title="8:30"></a>8:30</h2><p>开 T1，感觉可以贪心，注意其实是把 $s,t$ 分成了几个部分，每一部分随意交换，那么对于任意一个数字，应该优先让他产生贡献最优 balabala，手玩发现确实是贪心。</p><p>贪，可劲儿贪，直接贪就贪完了。</p><p>好像细节有亿点点多呢……</p><h2 id="9-00"><a href="#9-00" class="headerlink" title="9:00"></a>9:00</h2><p>好，过小样例了！</p><p>测大样例之前突发奇想，发现如果把小样例倒过来可以成一组强度不错的样例。</p><p>艹，假了。</p><p>调，可劲儿调，直接调就调完了。</p><h2 id="9-30"><a href="#9-30" class="headerlink" title="9:30"></a>9:30</h2><p>发现如果换一种方式如果只枚举 $s$ 上的索引能好一点，果断重构。</p><h2 id="9-50"><a href="#9-50" class="headerlink" title="9:50"></a>9:50</h2><p>红温了。</p><h2 id="10-00"><a href="#10-00" class="headerlink" title="10:00"></a>10:00</h2><p>果断放弃，看 T2T3T4。</p><p>T2 数数，T3 好不容易看懂了发现是数数，T4 至少有一个简单的式子。</p><p>那么我们先写 T4 的 $\mathcal{O}(n^2 \log n)$ 暴力。</p><h2 id="10-20"><a href="#10-20" class="headerlink" title="10:20"></a>10:20</h2><p>诶，大样例 WA 了，怎么会逝呢。</p><h2 id="11-00"><a href="#11-00" class="headerlink" title="11:00"></a>11:00</h2><p>nm 我 LCA 写错了。</p><p>增加了一个字符之后过了。</p><p>之后看 T2，毕竟 T3 一眼神秘。</p><p>简单推一推式子，随便写了一个东西胡上去。</p><p>诶，大样例过的点惊人的多，至少没有 WA 飞。</p><p>再推一会式子，看不出来自己哪错了，毕竟我心知肚明自己数数就是一坨。</p><h2 id="12-10"><a href="#12-10" class="headerlink" title="12:10"></a>12:10</h2><p>那我们继续看 T1。想了许多做法修正 T1 的问题，好像效力不大。</p><h2 id="12-40"><a href="#12-40" class="headerlink" title="12:40"></a>12:40</h2><p>偶然发现如果 $i,j$ 符合一种特殊结构那么直接清空 $j$ 的 $cnt$ 即可。</p><p>实在不想面对一坨史山。</p><p>来，我们还有 20min，删掉代码，重构！</p><h2 id="12-55"><a href="#12-55" class="headerlink" title="12:55"></a>12:55</h2><p>写完了，先跑小样例。</p><p>过了，那么小样例倒着跑。</p><p>过了。诶不对假做法也能过。</p><p>那么我们打印中间变量。</p><p>符合预期，大样例来不及测了，打上文件输入输出直接润。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉还行吧，对于现在的我应该也就是这个水平了。</p><p>问题在于不会 T2，可能是自己几乎没上文化课的缘故，大家说是一眼题。</p><p>大概是数数太烂了，要加训数数。</p><p>后来回过神我特殊性质 B 全部 WA 了，如果当时好好看一看特殊性质说不定是可以想出正解的。</p><p>但是那样应该 T1 就没办法了吧。</p><p>Upd:</p><p><img src="/img/%E6%88%AA%E5%9B%BE%202024-11-30%2015-55-08.png" alt="截图 2024-11-30 15-55-08"></p><p>不是怎么就是没想到 st 表呢。</p><p>但是感觉不会 T4 不会卡掉带一个 $\log$ 的暴力，感觉（。</p><p>希望 T1 神明保佑能过。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>扩展欧几里得</title>
    <link href="/2024/10/01/exgcd/"/>
    <url>/2024/10/01/exgcd/</url>
    
    <content type="html"><![CDATA[<h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>扩展欧几里德算法用于求解形如 $ax + by &#x3D; \gcd(a, b)$ 的等式。这是裴蜀等式，我们接下来的内容可以证明它一定有解。</p><p>我们知道：</p><p>$$<br>\gcd(a, b) &#x3D; \gcd(b, a \bmod b)<br>$$</p><p>那么有：</p><p>$$<br>\begin{align}<br>ax + by &amp; &#x3D; \gcd(a, b) \newline<br>&amp; &#x3D; \gcd(b, a \bmod b)<br>\end{align}<br>\Rightarrow<br>bx’ + (a \bmod b) y’ &#x3D; \gcd(b, a\bmod b) &#x3D; \gcd(a, b)<br>$$</p><p>联系到欧几里德算法的终止条件 <code>b == 0</code>，此时不难直接得到 $x &#x3D; 1$，$y$ 取值任意。我们发现，迭代的下一层的解一定比上一层的要早得到，考虑如何转移：</p><p>$$<br>\begin{align}<br>bx’ + (a \bmod b) y’ &amp; &#x3D; bx’ + (a - \left\lfloor \dfrac{a}{b} \right\rfloor \cdot b) y’ \newline<br>&amp; &#x3D; bx’ + ay’ - \left\lfloor \dfrac{a}{b} \right\rfloor \cdot b y’ \newline<br>&amp; &#x3D; ay’ + b(x’ - \left\lfloor \dfrac{a}{b} \right\rfloor \cdot y’) \newline<br>&amp; &#x3D; ax + by<br>\end{align}<br>\Rightarrow<br>\begin{cases}<br>x &#x3D; y’ \newline<br>y &#x3D; x’ - \left\lfloor \dfrac{a}{b} \right\rfloor \cdot y’<br>\end{cases}<br>$$</p><p>实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们尝试回代，可以发现裴蜀等式一定有解。</p><h2 id="求解同余方程"><a href="#求解同余方程" class="headerlink" title="求解同余方程"></a>求解同余方程</h2><p>$$<br>ax \equiv b \pmod m<br>$$</p><p>对于上式，可以转化为：<br>$$<br>ax + km &#x3D; b<br>$$<br>设 $d &#x3D; \dfrac{b}{\gcd(a, m)}$，对上式两边同除 $d$，得到：<br>$$<br>a \cdot \dfrac{x}{d} + m \cdot \dfrac{k}{d} &#x3D; \gcd(a, m)<br>$$<br>那么我们可以先求出 $\dfrac{x}{d}$ 与 $\dfrac{k}{d}$，同乘 $d$ 即为原方程解。</p><p>同时，不难发现 $ax \equiv b \pmod m$ 有解的充要条件即为 $\gcd(a, m) \mid b$。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩展中国剩余定理</title>
    <link href="/2024/10/01/excrt/"/>
    <url>/2024/10/01/excrt/</url>
    
    <content type="html"><![CDATA[<h2 id="中国剩余定理（孙子定理）"><a href="#中国剩余定理（孙子定理）" class="headerlink" title="中国剩余定理（孙子定理）"></a>中国剩余定理（孙子定理）</h2><blockquote><p>「物不知数」问题：有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><p>中国剩余定理用于求解同余方程组。普通的中国剩余定理要求各方程之间的模数必须两两互质。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>求出所有模数之积 $M$；</li><li>对于第 $i$ 个方程：<ol><li>计算 $k_i &#x3D; \frac{M}{m_i}$；</li><li>计算 $k_i$ 在 $\bmod m_i$ 意义下的逆元 $k_i^{-1}$；</li><li>计算 $c_i &#x3D; k_i k_i^{-1}$。</li></ol></li><li>同余方程组在 $\bmod M$ 意义下的唯一解为 $x \equiv \sum_{i &#x3D; 1}^k a_i c_i \pmod M$。</li></ol><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>首先证明 $x$ 对于任意 $i$ 均满足 $x \equiv a_i \pmod {m_i}$。当 $i \neq j$，有 $k_j \equiv 0 \pmod {m_i}$，故 $c_j \equiv k_j \equiv 0 \pmod {m_i}$，同时 $c_i \equiv k_i k_i^{-1}  \equiv 1 \pmod {m_i}$。</p><p>$$<br>\begin{align}<br>x &amp; \equiv \sum_{i &#x3D; 1}^k a_i c_i &amp; \pmod {m_i}\newline<br>&amp; \equiv a_i c_i &amp; \pmod {m_i}\newline<br>&amp; \equiv a_i k_i k_i^{-1} &amp; \pmod {m_i}\newline<br>&amp; \equiv a_i &amp; \pmod {m_i}\newline<br>\end{align}<br>$$</p><p>唯一性可以通过剩余系 + 模数全部互质证明。注意到如果模数间不互质，$k_j \equiv 0 \pmod {m_i}$ 不成立，$x$ 中除了 $i$ 以外的部分无法完全消除，会导致答案错误。</p><h2 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h2><p>exCRT 用于处理模数不两两互质的情况。这里我们考虑将两个同余方程合并成一个，满足新同余方程的解就是旧同余方程的解，并且做到不重不漏。</p><p>考虑以下同余方程组：</p><p>$$<br>\begin{cases}<br>x \equiv a_1 \pmod {m_1}\newline<br>x \equiv a_2 \pmod {m_2}\newline<br>\end{cases}<br>$$</p><p>等价于：</p><p>$$<br>x &#x3D; a_1 + m_1 k_1 &#x3D; a_2 + m_2 k_2<br>$$</p><p>调整一下：</p><p>$$<br>m_1 k_1 - m_2 k_2 &#x3D; a_2 - a_1<br>$$</p><p>不难发现这是一个同余方程，设 $d &#x3D; \gcd(m_1, m_2),p_i &#x3D; \dfrac{m_i}{d}$，那么有：</p><p>$$<br>p_1 k_1 - p_2 k_2 &#x3D; \dfrac{a_2 - a_1}{d}<br>$$</p><p>我们可以用 exgcd 求：</p><p>$$<br>\lambda_1 p_1 + \lambda_2 p_2 &#x3D; 1<br>$$</p><p>得到：</p><p>$$<br>\begin{cases}<br>k_1 &#x3D; \dfrac{\lambda_i (a_2 - a_1)}{d}\newline<br>k_2 &#x3D; -\dfrac{\lambda_i (a_2 - a_1)}{d}<br>\end{cases}<br>$$</p><p>这样我们就可以求得一个特解 $x’$，通过剩余系，我们还可以证明两个方程的通解为 $x’ + k\operatorname{lcm}(m_1, m_2)$。也就是说，新的方程即为：</p><p>$$<br>x \equiv x’ \pmod {\operatorname{lcm}(m_1, m_2)}<br>$$</p><p>实际的做法如下：</p><ol><li>假设已经求得前 $i - 1$ 个方程的解 $ans$；</li><li>设 $M &#x3D; \operatorname{lcm}(m_1, m_2, \cdots m_{i - 1})$，则有 $\forall a_{i} \in \mathbb{Z},ans + Mx$ 是前 $i-1$ 个方程的通解；</li><li>想要得到前 $i$ 个方程的通解，就是要找到一个 $x$ 满足 $ans + Mx \equiv a_i \pmod {m_i}$；</li><li>移项得到 $Mx \equiv a_i - ans \pmod {m_i}$；</li><li>转化成 exgcd 的基本形式：</li></ol><p>$$<br>M x + k m_i &#x3D; a_i - ans<br>$$</p><h3 id="扩展扩展中国剩余定理（雾"><a href="#扩展扩展中国剩余定理（雾" class="headerlink" title="扩展扩展中国剩余定理（雾"></a>扩展扩展中国剩余定理（雾</h3><p>实际上是[NOI2018]屠龙勇士啦。</p><p>我们来考虑有系数 $b_i$ 的情况：</p><ol><li>假设已经求得前 $i - 1$ 个方程的解 $ans$；</li><li>设 $M &#x3D; \operatorname{lcm}(m_1, m_2, \cdots m_{i - 1})$，则有 $\forall a_{i} \in \mathbb{Z},ans + Mx$ 是前 $i-1$ 个方程的通解；</li><li>想要得到前 $i$ 个方程的通解，就是要找到一个 $x$ 满足 $b_i(ans + Mx) \equiv a_i \pmod {m_i}$；</li><li>移项得到 $b_i Mx \equiv a_i - b_i ans \pmod {m_i}$；</li><li>转化成 exgcd 的基本形式：</li></ol><p>$$<br>b_i M x + k m_i &#x3D; a_i - b_ians<br>$$</p><p>两者如出一辙。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>减半警报器</title>
    <link href="/2024/10/01/%E5%87%8F%E5%8D%8A%E8%AD%A6%E6%8A%A5%E5%99%A8/"/>
    <url>/2024/10/01/%E5%87%8F%E5%8D%8A%E8%AD%A6%E6%8A%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>首次出现应该在 <a href="https://codeforces.com/gym/102452/problem/I">2019-2020 ICPC Asia Hong Kong Regional Contest I. Incoming Asteroids</a></p><p>考虑如下问题：</p><p>有 $n$ 个位置，$m$ 个警报器，每个警报器监测比较少的几个位置（大概是常数级别），警报器在某一时刻开启后，如果监测的几个位置发生的事件（每个事件只在比较少的几个位置发生）阈值总和大于警报器的阈值，就报警（警报器开启前发生的事件不会对警报器造成影响，每个警报器只报警一次）。<br><strong>减半警报器</strong>可以做到 $\log^2$，zak 提出的<strong>二进制警报器</strong>可以做到单 $\log$。</p></blockquote><h2 id="减半警报器"><a href="#减半警报器" class="headerlink" title="减半警报器"></a>减半警报器</h2><p>把每个警报器单独拿出来看：</p><p>设现在有一个警报器报警阈值为 $y$，总共监测 $k$ 个位置。根据鸽笼原理，警报器想要报警，那么他所监测的某一个位置的阈值一定大于等于 $\left\lceil \frac{y}{k} \right\rceil$。考虑将一个大的警报器分散成几个小的警报器监测某一个位置。注意到警报器监测的位置比较少，因此修改考虑可以暴力维护。</p><p>然后每一个位置存一个当前总共发生过的事件阈值总和 $\texttt{tag}$，用一个可删堆维护当前位置所有的小警报器即可。如何消除之前发生过的事件的影响：插入大警报器时差分一下即可。小警报器报警就大力重构大警报器即可。</p><p>时间复杂度：注意到每次小警报器报警一个大警报器的阈值至少会下降 $\left\lceil \frac{y}{k} \right\rceil$，重构次数一定小于 $\log_{\frac{k}{k-1}} y$，加上可删堆的一只 $\log$ 总体复杂度一般为 $\mathcal{O}(n \log m \log V)$。</p><blockquote><p>例题：</p><p>P7603 [THUPC 2021] 鬼街</p><p>GYM102452I. Incoming Asteroids</p><p>以上都可以利用 zak 的二进制警报器优化到单 $\log$。</p></blockquote><h2 id="二进制警报器"><a href="#二进制警报器" class="headerlink" title="二进制警报器"></a>二进制警报器</h2><p>Todo.</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分块奇妙题</title>
    <link href="/2024/10/01/%E5%88%86%E5%9D%97%E5%A5%87%E5%A6%99%E9%A2%98/"/>
    <url>/2024/10/01/%E5%88%86%E5%9D%97%E5%A5%87%E5%A6%99%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>线段树和平衡树是具有局限性的，但是分块可以通过多样的 trick 处理多样的信息。</p><p>—— FDsama</p></blockquote><h2 id="P4168-Violet-蒲公英"><a href="#P4168-Violet-蒲公英" class="headerlink" title="P4168 [Violet] 蒲公英"></a>P4168 [Violet] 蒲公英</h2><blockquote><p>无修改区间众数， $1\le n \le 40000$，$1\le m \le 50000$，$1\le a_i \le 10^9$。</p></blockquote><p>首先离散化，记 $f_{i,j}$ 为第 $i$ 块到第 $j$ 块的区间众数，$cnt_{i,j}$ 表示前 $i$ 块 $j$ 出现的次数，两个可以 $\mathcal{O}(n \sqrt n)$ 预处理。然后我们开一个桶记录散块中每个数字出现的次数。遍历散块，如果发现<strong>某个数字散块中出现的次数 + 整块中出现的次数 &gt; 整块的众数在散块中出现的次数 + 在整块中出现的次数</strong>，就更新答案，因此做到了 $\mathcal{O}(n \sqrt n)$ 预处理 + $\mathcal{O}(\sqrt n)$ 回答询问。</p><h2 id="P5048-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-III"><a href="#P5048-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-III" class="headerlink" title="P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III"></a>P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III</h2><p>我宣布这是 Ynoi 系列最良心分块题！！！</p><blockquote><p>无修改求区间众数出现次数， $1\le n, m, a_i \le 5 \times 10^5$，空间仅够 $O(n)$ 通过。</p></blockquote><p>对每个 $a_i$ 开一个 <code>vector</code>，存储 $a_i$ 每一出现的位置。设 $f_{i, j}$ 表示第 $i$ 块到第 $j$ 块的区间众数出现次数。回答询问时先取整块众数的出现次数 $ans$，遍历散块，以右侧的散块为例：从左至右遍历，对于一个位置 $a_i$，从 <code>vector</code> 里取出它 $a_i$ 前 $ans$ 的位置，对于这个位置，如果它满足 $pos \ge l$，则它在询问区间内出现的次数一定 $&gt; ans$，使 $ans \leftarrow ans + 1$；同时由于我们从左至右遍历，可以做到每次更新 $ans$ 都保证前 $ans$ 的位置满足 $pos \ge l$ 而前 $ans + 1$ 的位置满足 $pos &lt; l$，算法的正确性得以保证。左侧散块同理，但是要注意顺序。</p><p>实际代码只有 52 行，没卡常但最多一个点只跑了 1.46s&#x2F;2.00s。</p><h2 id="P2801-教主的魔法"><a href="#P2801-教主的魔法" class="headerlink" title="P2801 教主的魔法"></a>P2801 教主的魔法</h2><blockquote><p>静态区间求元素排名。</p></blockquote><p>分块，对于每个块排序。查询时整块 <code>lower_bound</code>，散块暴力，复杂度 $\mathcal{O}(n \sqrt n \log \sqrt n)$。</p><p>想要做到更快的复杂度需要套值域分块，学会未来日记之后不难想。</p><h2 id="P4135-作诗"><a href="#P4135-作诗" class="headerlink" title="P4135 作诗"></a>P4135 作诗</h2><blockquote><p>求区间内出现偶数次的元素个数</p></blockquote><p>可以离线的话莫队，但是强制在线。设 $cnt_{i,j}$ 为前 $i$ 块 $j$ 出现次数，$f_{i, j}$ 为 $i \sim j$ 块的答案，经典前缀和 trick + 散块暴力不难。</p><h2 id="P4119-Ynoi2018-未来日记"><a href="#P4119-Ynoi2018-未来日记" class="headerlink" title="P4119 [Ynoi2018] 未来日记"></a>P4119 [Ynoi2018] 未来日记</h2><p><a href="https://www.bilibili.com/video/BV1fi4y1P7oj">视频链接</a></p><p>最初分块，经典 trick：分块套值域分块。</p><p>初见容易想到前缀和每个数字出现次数 + 二分。</p><p>但是不行，因为差分到区间内数字出现次数就是 $\mathcal{O}(n \sqrt n)$，乘上二分的 $\log$ 复杂度无法接受。引用题解的话说，主席树之所以可以二分是因为主席树的树形结构先天性的决定了它对二分的适配性，而分块适用于一些更暴力的算法，例如：对值域分块。</p><p>联系到之前的前缀和，我们依然有散块暴力 + 整块 $\mathcal{O}(1)$ 处理的 $\mathcal{O}(\sqrt n)$ 做法。考虑毒瘤的修改。</p><p>发现修改的都是把某一种数合并到另一种数上，这样想到可以把块中相同的数字塞到并查集里。对于每一个块其中的并查集存一个 $rt_{i,j}$，表示第 $i$ 个块数值为 $j$ 的并查集的根。考虑整块的合并，如果 $y$ 所对应的并查集存在，那么 <code>fa[rt[i][x]] = rt[i][y]</code>；如果不存在，那么直接修改 $rt_{i,x}$ 处的值为 $y$，同时 <code>rt[i][y] = rt[i][x], rt[i][x] = 0</code>，这样就相当于把 $x$ 所对应的整棵并查集搬到 $y$ 的位置。接下来考虑散块：直接暴力重构 $x,y$ 所对应的并查集。</p><p>对于并查集完成修改后，我们又发现对于后来的前缀和数组的修改是 $\mathcal{O}(\sqrt n)$ 级别的，可以接受。</p><p><a href="https://www.luogu.com.cn/record/194208675">实际实现</a>：<code>C++ 98 -O2</code>，值域块长 320，序列块长 600，最大一个点 833ms。删去超快读 121 行，Ynoi 里不算多吧。</p><p><img src="/img/13174.png" alt="图片"></p><h2 id="P4278-带插入区间K小值"><a href="#P4278-带插入区间K小值" class="headerlink" title="P4278 带插入区间K小值"></a>P4278 带插入区间K小值</h2><p>序列分块+值域分块，每个序列块维护一个链表，保证链表的长度，然后存一个前缀 $cnt$，每次插入依次修改后边块的 $cnt$ 即可，时间复杂度 $O(n \log n)$。</p>]]></content>
    
    
    
    <tags>
      
      <tag>分块</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论函数</title>
    <link href="/2024/10/01/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/"/>
    <url>/2024/10/01/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>定义：定义域是 $\mathbb{Z^+}$，值域是 $\mathbb{C}$ 的函数。</p><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>我们称当 $\gcd(i, j) &#x3D; 1$ 时满足<br>$f(i \times j) &#x3D; f(i) \times f(j)$<br>的数论函数为<strong>积性函数</strong>；称 $\forall i, j \in \mathbb{Z^+}$ 满足 $f(i \times j) &#x3D; f(i) \times f(j)$<br>的数论函数为<strong>完全积性函数</strong>。本文中提到的所有函数均是积性函数，其中单位函数，幂函数是完全积性函数。</p><h2 id="单位函数"><a href="#单位函数" class="headerlink" title="单位函数"></a>单位函数</h2><p>$$<br>\varepsilon(n) &#x3D; [n &#x3D; 1]<br>$$</p><h2 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h2><p>$$<br>\operatorname{Id}_k(n) &#x3D; n ^ k<br>$$</p><p>一般不写下标的情况，指的就是 $k &#x3D; 1$。</p><h2 id="除数函数"><a href="#除数函数" class="headerlink" title="除数函数"></a>除数函数</h2><p>$$<br>\sigma_k(n) &#x3D; \sum\limits_{d \mid n} d^k<br>$$</p><h2 id="常数函数"><a href="#常数函数" class="headerlink" title="常数函数"></a>常数函数</h2><p>即为 $f(x) &#x3D; m$（$m$ 是常数）的函数，注意到它是完全积性函数、偶函数，最常用的是 $\mathbf{1}(x) &#x3D; 1$，注意函数名上的 $\mathbf{1}$ 要写成粗体。</p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$$<br>\varphi(n) &#x3D; \sum\limits_{i &#x3D; 1}^n [\gcd(i, n) &#x3D; 1]<br>$$</p><p>性质：</p><ul><li>$\varphi$ 是积性函数。</li><li>$n &#x3D; \sum\limits_{d \mid n} \varphi(d)$，也就是说 $\varphi * \mathbf1 &#x3D; \operatorname{Id}_1$，反过来也有 $\mu * \operatorname{Id}_1 &#x3D; \varphi$，证明参见狄利克雷卷积。</li><li>若 $n &#x3D; p^k \mid p \in \mathbb{P}$，则有 $p^{k - 1}$ 个数与 $n$ 不互质，那么 $\varphi(n) &#x3D; p^k - p^{k - 1} &#x3D; p^{k - 1} \cdot(p - 1)$。</li><li>设 $n &#x3D; \prod\limits_{i &#x3D; 1}^k p_i^{c_i} \mid p \in \mathbb{P}$，则 $\varphi(n) &#x3D; n \prod\limits_{p|n} (1 - \frac{1}{p}) \mid p \in \mathbb{P}$。</li></ul><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><p>莫比乌斯函数 $\mu$ 定义为：<br>$$<br>\mu(n) &#x3D;<br>\begin{cases}<br>1 &amp; n &#x3D; 1 \newline<br>0 &amp; n \ 含有两个及以上个相同的因子\newline<br>(-1) ^ k &amp; k \ 为 \ n \ 本质不同的因数个数<br>\end{cases}<br>$$<br>容易发现莫比乌斯函数是积性函数，因此可以线性筛求。</p><p>莫比乌斯函数具有以下性质：<br>$$<br>\sum_{d \mid n} \mu(d) &#x3D; [n &#x3D; 1]<br>$$<br>证明：</p><p>设 $n &#x3D; \prod\limits_{i &#x3D; 1}^k p_i^{c_i}, n’ &#x3D; \prod\limits_{i &#x3D; 1}^k p_i$。那么根据定义，显然有 $\sum\limits_{d \mid n} \mu(d) &#x3D; \sum\limits_{d \mid n’} \mu(d)$，这是因为右侧中比左侧少统计的 $\mu(d)$ 的答案一定为 $0$。统计答案为 $(-1)^i$ 的答案个数，为 $ki$。我们将求和式转为枚举 $\mu(d)$ 的值，有：<br>$$<br>\sum_{d \mid n’} \mu(d) &#x3D; \sum_{i &#x3D; 0}^k {k \choose i} (-1)^i &#x3D; \sum_{i &#x3D; 0}^k {k \choose i} (-1)^i \cdot 1^{k - i}<br>$$<br>根据二项式定理：上式为 $(1 + (-1))^k$。Q.E.D.</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯特林数</title>
    <link href="/2024/10/01/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <url>/2024/10/01/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><blockquote><p>圆排列将数字排成一个环，我们认为两个环本质不同当且仅当存在某个位置的前驱或后继不同.</p></blockquote><blockquote><p>例如：<code>1, 2, 3</code> 与 <code>3, 1, 2</code> 是本质相同的两个圆排列，<code>1, 2, 3</code> 与 <code>1, 3, 2</code> 是本质不同的两个圆排列。</p></blockquote><p>记 ${n \brack m}$ 为将 $n$ 个互不相同的元素划分为 $m$ 个互不区分的非空圆排列的方案数，有递推式：<br>$$<br>{n \brack m} &#x3D; {n - 1 \brack m - 1} + (n - 1) {n - 1 \brack m}<br>$$</p><blockquote><p>证明：左侧即为将新来的元素单独放到一个空圆排列中，右侧为将新来的元素放到原有的 $n - 1$ 个数的后继。</p></blockquote><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>记 ${n \brace m}$ 为将 $n$ 个互不相同的元素划分为 $m$ 个互不区分的非空集合的方案数，即为：将 $n$ 个有标号小球放入 $m$ 个无标号盒子（每个盒子至少有一个小球）的方案数。有递推式：<br>$$<br>{n \brace m} &#x3D; {n - 1 \brace m - 1} + m \cdot {n - 1 \brace m}<br>$$</p><blockquote><p>证明：左侧即为将新来的元素单独放到一个空集合中，右侧为将新来的元素放到原有的集合中。</p></blockquote><p>那么相互区分的集合怎么办？显然只需乘上 $m!$。</p><p>同时，有通项公式：<br>$$<br>{n \brace m} &#x3D; \frac{1}{m!} \sum_{i &#x3D; 0}^m (-1)^i {m \choose i} (m - i)^n<br>$$</p><blockquote><p>证明：考虑更简单的情况：盒子有标号，那么只要将答案除以 $m!$ 即为无标号的结果。</p></blockquote><blockquote><p>进一步的，假如集合可以为空，设 $f(x)$ 为钦定有 $x$ 个集合为空的方案数，$g(x)$ 为恰好 $x$ 个集合为空的方案数。不难得到：<br>$$<br>f(x) &#x3D; \sum_{i &#x3D; x}^m {i \choose x} g(i) &#x3D; {m \choose x} (m - x)^n<br>$$<br>二项式反演：<br>$$<br>\begin{align}<br>g(x) &amp; &#x3D; \sum_{i &#x3D; x}^m {i \choose x} (-1)^{i - x} f(i) \newline<br>&amp; &#x3D; \sum_{i &#x3D; x}^m {i \choose x} (-1)^{i - x} {m \choose i} (m - i)^n<br>\end{align}<br>$$<br>得到集合不可以为空的情况为 $g(0)$，证毕。</p></blockquote><p>我们还可对通项公式进行二项式反演，得到：<br>$$<br>m^n &#x3D; \sum_{i &#x3D; 0}^m {m \choose i} i! {n \brace i}<br>$$<br>组合意义上，这指的是将 $n$ 个有标号小球放入 $m$ 个有标号盒子内、盒子可空的方案数（还可以通过枚举空盒子个数结合第二类斯特林数进行证明）。</p><h2 id="上升-下降幂"><a href="#上升-下降幂" class="headerlink" title="上升&#x2F;下降幂"></a>上升&#x2F;下降幂</h2><p>上升幂：<br>$$<br>n^\overline m &#x3D; \prod_{i &#x3D; n}^{n + m - 1} i<br>$$</p><p>下降幂：<br>$$<br>n^\underline m &#x3D; \prod_{i &#x3D; n}^{n - m + 1} i &#x3D; \frac{n!}{(n - m)!}<br>$$</p><p>不难发现下降幂即为排列数，为 $m! {n \choose m}$。</p><h3 id="上升-下降幂间的转换"><a href="#上升-下降幂间的转换" class="headerlink" title="上升&#x2F;下降幂间的转换"></a>上升&#x2F;下降幂间的转换</h3><p>$$<br>\begin{align}<br>x^\overline n &#x3D; (-1)^n (-x)^\underline n\newline<br>x^\underline n &#x3D; (-1)^n (-x)^\overline n<br>\end{align}<br>$$</p><blockquote><p>证明： 以上式为例，强行展开：<br>$$<br>\begin{align}<br>x^\overline n &amp;&#x3D; \prod_{i &#x3D; 1}^{n} x + i - 1 \newline<br>&amp;&#x3D; (-1)^n \prod_{i &#x3D; 1}^n -x - i + 1\newline<br>&amp;&#x3D; (-1)^n (-x)^\overline n<br>\end{align}<br>$$</p></blockquote><blockquote><p>下式以此类推。</p></blockquote><h2 id="斯特林数结合上升-下降幂"><a href="#斯特林数结合上升-下降幂" class="headerlink" title="斯特林数结合上升&#x2F;下降幂"></a>斯特林数结合上升&#x2F;下降幂</h2><h3 id="通常幂转下降幂"><a href="#通常幂转下降幂" class="headerlink" title="通常幂转下降幂"></a>通常幂转下降幂</h3><p>$$<br>n^m &#x3D; \sum_{i &#x3D; 0}^m {m \brace i} n^\underline i<br>$$</p><blockquote><p>证明考虑组合意义：</p></blockquote><blockquote><p>$n^m$ 表示将 $m$ 个有标号球放到 $n$ 个有标号盒子的方案数，无其他限制。</p></blockquote><blockquote><p>则枚举非空的盒子个数（第二类斯特林数）并乘上排列数即可得到原式。</p></blockquote><h3 id="上升幂转通常幂"><a href="#上升幂转通常幂" class="headerlink" title="上升幂转通常幂"></a>上升幂转通常幂</h3><p>$$<br>n^\overline m &#x3D; \sum_{i &#x3D; 0}^m {m \brack i} n^i<br>$$</p><blockquote><p>证明考虑数学归纳：</p></blockquote><blockquote><p>当 $m &#x3D; 1$ 时，显然成立。</p></blockquote><blockquote><p>当 $m &gt; 1$ 时，归纳得 $m - 1$ 时成立。</p></blockquote><blockquote><p>左侧拆开：<br>$$<br>n^\overline m &#x3D; n^\overline{m - 1} (n + m - 1)<br>$$<br>代入结论：<br>$$<br>\begin{align}<br>&amp;n^\overline{m - 1} (n + m - 1)\newline<br>&#x3D;&amp; \sum_{i &#x3D; 0}^{m - 1} {m - 1 \brack i} n^i (n + m - 1)\newline<br>&#x3D;&amp; \sum_{i &#x3D; 0}^{m - 1} {m - 1 \brack i} n^{i + 1} + \sum_{i &#x3D; 0}^{m - 1} {m - 1 \brack i} n^i(m - 1)\newline<br>&#x3D;&amp; \sum_{i &#x3D; 1}^{m} {m - 1 \brack i - 1} n^{i} + \sum_{i &#x3D; 0}^{m - 1} (m - 1){m - 1 \brack i} n^i\newline<br>&#x3D;&amp; \sum_{i &#x3D; 0}^{m} \left({m - 1 \brack i - 1} + (m - 1){m - 1 \brack i}\right) n^i - {m - 1 \brack 0 - 1} n^0 - (m - 1){m - 1 \brack m} n^m<br>\end{align}<br>$$<br>多出来的两项无意义，直接就为 $0$ 了。</p></blockquote><blockquote><p>然后求和式中间的是第一类斯特林数的递推式，得：<br>$$<br>\sum_{i &#x3D; 0}^m {m \brack i} n^i<br>$$<br>原式得证。</p></blockquote><h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2><p>$$<br>f(n) &#x3D; \sum_{i &#x3D; 0}^n {n \brace i} g(i) \Leftrightarrow g(n) &#x3D; \sum_{i &#x3D; 0}^n (-1)^{n - i}{n \brack i} f(i)<br>$$</p><h3 id="反转公式"><a href="#反转公式" class="headerlink" title="反转公式"></a>反转公式</h3><p>根据反演的前提条件，需证明：<br>$$<br>\left{<br>\begin{align}<br>\sum_{i &#x3D; j}^n(-1)^{n - i} {n \brack i} {i \brace j} &#x3D; [j &#x3D; n]\newline<br>\sum_{i &#x3D; j}^n(-1)^{n - i} {n \brack i} {i \brace j} &#x3D; [j &#x3D; n]\newline<br>\end{align}<br>\right.<br>$$<br>这个公式也被称为反转公式。</p><blockquote><p>证明</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
      <tag>组合计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉定理</title>
    <link href="/2024/10/01/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    <url>/2024/10/01/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$$<br>\varphi(n) &#x3D; \sum\limits_{i &#x3D; 1}^n [\gcd(i, n) &#x3D; 1]<br>$$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>$\varphi$ 是<strong>积性函数</strong>。</li><li>$n &#x3D; \sum\limits_{d \mid n} \varphi(d)$，也就是说 $\varphi * \mathbf1 &#x3D; \operatorname{Id}_1$，反过来也有 $\mu * \operatorname{Id}_1 &#x3D; \varphi$，证明参见狄利克雷卷积。</li><li>若 $n &#x3D; p^k \mid p \in \mathbb{P}$，则有 $p^{k - 1}$ 个数与 $n$ 不互质，那么 $\varphi(n) &#x3D; p^k - p^{k - 1} &#x3D; p^{k - 1} \cdot(p - 1)$。</li><li>设 $n &#x3D; \prod\limits_{i &#x3D; 1}^k p_i^{c_i} \mid p \in \mathbb{P}$，则 $\varphi(n) &#x3D; n \prod\limits_{p|n} (1 - \frac{1}{p}) \mid p \in \mathbb{P}$。</li></ul><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>当 $a$，$m$ 满足 $\gcd(m, a) &#x3D; 1$，有：<br>$$<br>a^{\varphi(m)} \equiv 1 \pmod m<br>$$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设一个 $\bmod m$ 下的既约剩余系为 ${r_1, r_2, \dots, r_{\varphi(m)}}$，根据<em>既约剩余系与既约同余类的基本性质</em>，得到 ${ar_1, ar_2, \dots, ar_{\varphi(m)}}$ 也是 $\bmod m$ 意义下的既约剩余系，得到：<br>$$<br>\begin{align}<br>\prod_{i &#x3D; 1}^{\varphi(m)} r_i &amp;\equiv \prod_{i &#x3D; 1}^{\varphi(m)} ar_i &amp;\pmod m\newline<br>\prod_{i &#x3D; 1}^{\varphi(m)} r_i &amp;\equiv a^{\varphi(m)} \prod_{i &#x3D; 1}^{\varphi(m)} r_i &amp;\pmod m\newline<br>a^{\varphi(m)} &amp;\equiv 1 &amp;\pmod m\newline<br>\end{align}<br>$$</p><h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h2><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p>$$<br>a^{c} &#x3D;<br>\begin{cases}<br>a^{c \bmod \varphi(m)} &amp; \gcd(a, m) &#x3D; 1\newline<br>a^c &amp; \gcd(a, m) \neq 1,c &lt; \varphi(m)\newline<br>a^{c \bmod \varphi(m) + \varphi(m)} &amp; \gcd(a, m) \neq 1,c \ge \varphi(m)\newline<br>\end{cases}<br>$$</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h4><p>由欧拉定理易证。</p><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h4><p>这部分说明了什么时候无法进行降幂操作，同余式显然成立。</p><h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h4><p>为了证明 case 3，我们只需证明对于 $a$ 的任意一个质因子 $p$，都满足：<br>$$<br>p^c \equiv p^{c \bmod \varphi(m) + \varphi(m)} \pmod m<br>$$<br>考虑证明。若 $\gcd(m,p) &#x3D; 1$，符合 case 1 的性质，无需再次证明。</p><p>若 $\gcd(m, p) \neq 1$ 且 $p$ 是质数，那么得到 $m \ge 2p$，设 $m &#x3D; s \cdot p^r (\gcd(s, p) &#x3D; 1)$，这就相当于我们把 $m$ 分成两部分，$p^r$ 含有 $m$ 中所有质因子 $p$，而 $s$ 是 $m$ 去掉所有质因子 $p$ 之后剩下的部分。可以得到 $p^{\varphi(s)} \equiv 1 \pmod s$ 和 $\varphi(m) &#x3D; \varphi(s) \cdot \varphi(p^r)$。进一步的：<br>$$<br>p^{\varphi(m)} \equiv (p^{\varphi(s)})^{\varphi(p^r)} \equiv 1^{\varphi(p^r)} \equiv 1 \pmod s<br>$$<br>同乘 $p^r$：<br>$$<br>p^{\varphi(m) + r}  \equiv p^r \pmod {s \cdot p^r}<br>$$<br>由于 $m &#x3D; s \cdot p^r$，有：<br>$$<br>p^{\varphi(m) + r}  \equiv p^r \pmod m<br>$$<br>根据题设，有 $c \ge \varphi(m)$，下面我们先证明 $\varphi(m) \ge r$：</p><blockquote><p>首先 $\varphi(m) &#x3D; \varphi(s) \cdot \varphi(p^r)$，若能证明 $\varphi(p^r) \ge r$，则原式得证。</p><p>$\varphi(p^r) &#x3D; p^r - p^{r - 1} \ge p^{r - 1}$，若能证明 $p^{r - 1} \ge r$，则原式得证。采用<strong>第一数学归纳法</strong>，易知 $r &#x3D; 1$ 时不等式成立，假设 $r &#x3D; k$ 时不等式成立，欲证明 $r &#x3D; k + 1$ 时不等式成立：<br>$$<br>p^{k + 1} &#x3D; p^k \cdot p \ge 2 p^k &#x3D; p^k + p^k \ge p^k + 1 \ge (k + 1) + 1 &#x3D; k + 2<br>$$<br>证毕。</p></blockquote><p>通过以上证明，我们得到（上一步证明是必须的，我们不能保证 $p$ 在 $\bmod m$ 意义下一定有逆元，因此只有这样才能避免在同余方程中出现负数次幂），$p^c \equiv p^{c - r} \cdot p^{r + \varphi(m)} \equiv p^{c + \varphi(m)} \pmod m$。</p><p>设 $f(x) &#x3D; p^x \bmod m \ (x \ge \varphi(m))$，从上式得到 $f(x) &#x3D; f(x + \varphi(x))$，同理有 $f(x) &#x3D; f(x - \varphi(x))$。此时可以递推。但是更进一步的，我们发现一直递推后会得到 $0 \le c \le \varphi(m)$，为了避免它不符合定义域，只要减少一步递推即可，实际上就是 $c \bmod \varphi(m) + \varphi(m)$。则 case 3 得证。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="/2024/10/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <url>/2024/10/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<p>前置芝士：数论函数。</p><h1 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>两个数论函数的狄利克雷卷积为：<br>$$<br>(f * g)(n) &#x3D; \sum_{d \mid n} f(n) g!\left(\dfrac{n}{d}\right)<br>$$<br>经过观察我们可以发现狄利克雷卷积满足交换律，结合律，分配律。</p><h2 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h2><p>单位函数满足 $(f * \varepsilon)(n) &#x3D; f(n)$，我们称他是狄利克雷函数中的单位元，可以证明：<br>$$<br>\varepsilon &#x3D; \mu * \mathbf 1<br>$$<br>证明：<br>$$<br>(f * \varepsilon)(n) &#x3D; \sum_{d \mid n} f(d) \varepsilon !<br>\left(\dfrac{n}{d}\right) &#x3D; \sum_{d \mid n} f(d) \left[\dfrac{n}{d} &#x3D; 1\right]<br>$$<br>根据莫比乌斯函数的性质，得到 $\varepsilon &#x3D; \mu * \mathbf1$。</p><h2 id="结合数论函数"><a href="#结合数论函数" class="headerlink" title="结合数论函数"></a>结合数论函数</h2><ul><li><p>除数函数与幂函数满足 $1 * \operatorname{Id}_k &#x3D; \sigma_k$。特别的，当 $k &#x3D; 0$ 时，有 $\operatorname{Id}_0 &#x3D; 1$，也就是说 $1 * 1 &#x3D; \sigma_0$。</p></li><li><p>欧拉函数与恒等函数满足 $\varphi * 1 &#x3D; \operatorname{Id}_1$。证明：</p></li></ul><p>首先考虑特殊情况，$n &#x3D; p^m$，那么有：<br>$$<br>  \begin{align}<br>  (\varphi * \mathbf1)(p^m) &amp; &#x3D; \sum_{d \mid n} \varphi(d)\newline<br>  &amp; &#x3D; \varphi(1) + \sum_{k &#x3D; 1}^m \varphi(p^k)\newline<br>  &amp; &#x3D; 1 + \sum_{k &#x3D; 1}^m p^k - p^{k - 1}\newline<br>  &amp; &#x3D; p^m<br>  \end{align}<br>$$<br>  因为 $\varphi * \mathbf1$ 是积性函数，根据唯一分解定理，对于任意正整数，都有：<br>$$<br>  \begin{align}<br>  (\varphi * \mathbf1)(n) &amp; &#x3D; \prod_{i &#x3D; 1}^k (\varphi * 1)(p_i^{c_i})\newline<br>  &amp; &#x3D; \prod_{i &#x3D; 1}^k p_i^{c_i}\newline<br>  &amp; &#x3D; n<br>  \end{align}<br>$$<br>  Q.E.D.</p><ul><li>结合上一条，有 $\varphi &#x3D; \operatorname{Id}_1 * \mu$。</li></ul><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>如果有函数 $f, g$，满足 $f * g &#x3D; \varepsilon$，那么称 $g$ 是 $f$ 的狄利克雷逆元。</p><h2 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h2><ol><li><strong>两个积性函数的狄利克雷卷积是积性函数</strong></li><li><strong>积性函数的狄利克雷逆元是积性函数</strong></li></ol><h1 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h1><h2 id="引理-1"><a href="#引理-1" class="headerlink" title="引理 1"></a>引理 1</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>$$<br>\forall n \in \mathbb{N},<br>\left| \left{ \left\lfloor \dfrac{n}{d} \right\rfloor \mid d\in<br>\mathbb{N} \right} \right|<br>\le \left\lfloor 2 \sqrt n \right\rfloor<br>$$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>当 $d \le \sqrt n$ 时，最坏情况下<br>$\left\lfloor \dfrac{n}{d} \right\rfloor$ 两两不同，共有 $\sqrt{n}$ 种情况；当 $d \gt \sqrt n$ 时，$\left\lfloor \dfrac{n}{d}\right\rfloor$最大为 $\sqrt n$，最坏情况下 $\left\lfloor \dfrac{n}{d} \right\rfloor$ 两两不同，共有 $\sqrt{n}$ 种情况。Q.E.D.</p><p>数论分块主要用来快速求使得 $\left\lfloor \dfrac{n}{d} \right\rfloor$ 相同的区间的左右断点。</p><h2 id="引理-2"><a href="#引理-2" class="headerlink" title="引理 2"></a>引理 2</h2><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>$$<br>\left\lfloor \frac{\left\lfloor<br>\frac{a}{b}\right\rfloor}{c}\right\rfloor &#x3D; \left\lfloor<br>\frac{a}{bc}\right\rfloor<br>$$</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>有 $a &#x3D; nb + p \ (0 \le p \lt b)$，$n &#x3D; mc + q \ (0 \le q \lt c)$，易知 $n &#x3D; \left\lfloor \frac{a}{b}\right\rfloor, m &#x3D; \left\lfloor \frac{\left\lfloor \frac{a}{b}\right\rfloor}{c}\right\rfloor$。将右式代入左式：<br>$$<br>\begin{align}<br>a &amp; &#x3D; b(mc + q) + p\newline<br>&amp; &#x3D; m \cdot bc + bq + p<br>\end{align}<br>$$<br>不难发现 $0 \le bq + p \lt bc$，则 $m &#x3D; \left\lfloor \frac{a}{bc}\right\rfloor$，原式得证。</p><h2 id="两个结论"><a href="#两个结论" class="headerlink" title="两个结论"></a>两个结论</h2><p>那么对于满足 $\left\lfloor \dfrac{n}{i} \right\rfloor &#x3D; \left\lfloor \dfrac{n}{r} \right\rfloor$ 的极大 $r$，满足：<br>$$<br>r &#x3D;<br>\left\lfloor \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor}<br>\right\rfloor<br>$$<br>证明：</p><p>首先有<br>$$<br>\begin{cases}<br>\left\lfloor \dfrac{n}{i} \right\rfloor \le \dfrac{n}{r} \newline<br>\dfrac{n}{r + 1} &lt; \left\lfloor \dfrac{n}{i} \right\rfloor<br>\end{cases}<br>$$<br>根据第一行：<br>$$<br>\left\lfloor \dfrac{n}{i} \right\rfloor \le \dfrac{n}{r}<br>\Rightarrow \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor} \ge<br>\dfrac{n}{\dfrac{n}{r}}<br>\Rightarrow \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor} \ge r<br>$$<br>根据第二行：<br>$$<br>\dfrac{n}{r + 1} \lt \left\lfloor \dfrac{n}{i} \right\rfloor<br>\Rightarrow \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor} \lt<br>\dfrac{n}{\dfrac{n}{r + 1}}<br>\Rightarrow \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor} \lt r + 1<br>$$<br>得到：<br>$$<br>r \le \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor} \lt r + 1<br>$$<br>由于 $r \in \mathbb{Z}$，得到最大的 $r$<br>为：<br>$$<br>\left\lfloor \dfrac{n}{\left\lfloor \dfrac{n}{i} \right\rfloor}<br>\right\rfloor<br>$$<br>同理，我们不难得到那么对于满足 $\left\lceil \dfrac{n}{i} \right\rceil &#x3D; \left\lceil \dfrac{n}{l} \right\rceil$ 的极小 $l$，满足：<br>$$<br>l &#x3D;<br>\left\lceil \dfrac{n}{\left\lceil \dfrac{n}{i} \right\rceil}<br>\right\rceil<br>$$<br>数论分块就是将这些内容分为连续的 $[l, r]$<br>并统一计算答案，广泛运用于莫比乌斯反演中。根据引理，复杂度一般为 $\mathcal{O(\sqrt n)}$。</p><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h2><p>若：<br>$$<br>f(n) &#x3D; (g * \mathbf1)(n) &#x3D; \sum_{d \mid n} g(d)<br>$$<br>那么有：<br>$$<br>g(n) &#x3D; (\mu * f)(n) &#x3D;\sum_{d \mid n} \mu(d) f !<br>\left(\dfrac{n}{d}\right)<br>$$</p><h2 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h2><p>若：<br>$$<br>f &#x3D; g * \mathbf1<br>$$<br>那么：<br>$$<br>\mu * f &#x3D; \mu * g * \mathbf1 &#x3D; g * \varepsilon &#x3D; g<br>$$<br>Q.E.D.</p><h2 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h2><p>$$<br>\sum_{i &#x3D; 1} ^ n \sum_{j &#x3D; 1} ^ m f(\gcd(i, j))<br>$$</p><p>构造一个函数 $g$，满足 $f &#x3D; (g * 1)$，那么有：</p><p>$$<br>\sum_{i &#x3D; 1} ^ n \sum_{j &#x3D; 1} ^ m \sum_{d \mid \gcd(i, j)} g(d)<br>$$</p><p>注意到如果 $d \mid \gcd(i, j)$，那么 $d \mid i$ 且 $d \mid j$。因此我们调整求和顺序：</p><p>$$<br>\sum_{d &#x3D; 1}^n g(d) \sum_{i &#x3D; 1} ^ n [d \mid i] \sum_{j &#x3D; 1} ^ m [d \mid j]<br>\Rightarrow<br>\sum_{d &#x3D; 1}^n g(d) \left\lfloor \dfrac{n}{d} \right\rfloor \left\lfloor \dfrac{m}{d} \right\rfloor<br>$$</p><p>此时可以数论分块。</p><h2 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h2><p>$$<br>\sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m \gcd(i, j)<br>$$</p><p>可以发现他等价于：<br>$$<br>\begin{aligned}<br>&amp; \sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m \operatorname{Id}(\gcd(i, j)) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1} ^ n \sum_{j &#x3D; 1} ^ m \sum_{d \mid \gcd(i, j)} \varphi(d) \newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n \varphi(d) \left\lfloor \dfrac{n}{d} \right\rfloor \left\lfloor \dfrac{m}{d} \right\rfloor<br>\end{aligned}<br>$$</p><p>还有一种方式：从求值改为枚举 $\gcd$：<br>$$<br>\begin{align}<br>&amp; \sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m \gcd(i, j) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m \sum_{d \mid i, d \mid j} [\gcd(i, j) &#x3D; d] \cdot d \newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n d \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{i &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i, j) &#x3D; 1]<br>\end{align}<br>$$<br>右边的单独拿出来设为 $f(d)$：<br>$$<br>\begin{align}<br>f(d)&#x3D; &amp; \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{i &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i, j) &#x3D; 1] \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{i &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} \sum_{t \mid i, t \mid j} \mu(t)\newline<br>&#x3D; &amp; \sum_{t &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(t) \left\lfloor \dfrac{n}{dt} \right\rfloor \left\lfloor \dfrac{m}{dt} \right\rfloor<br>\end{align}<br>$$<br>注意：最后一步用到了一个小结论 $\left\lfloor \dfrac{\left\lfloor \dfrac{a}{b} \right\rfloor}{c} \right\rfloor &#x3D; \left\lfloor \dfrac{a}{bc} \right\rfloor$，数论分块中有写。$f$ 算出来之后再扔回去，并设 $T &#x3D; dt$：</p><p>$$<br>\begin{align}<br>\sum_{d &#x3D; 1}^n d \cdot f(d) &#x3D; &amp; \sum_{d &#x3D; 1}^n d \sum_{t &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(t) \left\lfloor \dfrac{n}{dt} \right\rfloor \left\lfloor \dfrac{m}{dt} \right\rfloor \newline<br>&#x3D; &amp; \sum_{T &#x3D; 1}^n \sum_{d \mid T} \mu\left(\frac{T}{d}\right) d \left\lfloor \dfrac{n}{T} \right\rfloor \left\lfloor \dfrac{m}{T} \right\rfloor\newline<br>&#x3D; &amp; \sum_{T &#x3D; 1}^n \left\lfloor \dfrac{n}{T} \right\rfloor \left\lfloor \dfrac{m}{T} \right\rfloor \sum_{d \mid T} \mu\left(\frac{T}{d}\right) d\newline<br>\end{align}<br>$$</p><p>右边的东西就是 $\mu * \operatorname{Id}$，也就是 $\varphi$，不懂的可以看狄利克雷卷积。虽然这种方式不如之前的简洁，但是它运用了许多常用的 trick 富有教育意义。</p><h2 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h2><p>$$<br>\begin{aligned}<br>&amp; \sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m [\gcd(i, j) &#x3D; 1] \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^n \sum_{i &#x3D; 1}^m \varepsilon(\gcd(i, j)) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1} ^ n \sum_{j &#x3D; 1} ^ m \sum_{d \mid \gcd(i, j)} \mu(d) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1} ^ n \sum_{j &#x3D; 1} ^ m \sum_{d \mid i, d \mid j} \mu(d) \newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n \mu(d) \left\lfloor \dfrac{n}{d} \right\rfloor \left\lfloor \dfrac{m}{d} \right\rfloor<br>\end{aligned}<br>$$</p><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li>尝试将求 $\gcd$ 变为枚举 $\gcd$，争取得到一个 $[\gcd(i, j) &#x3D; 1]$，然后莫反 $[\gcd(i, j) &#x3D; 1] &#x3D; \sum_{d \mid \gcd(i, j)} \mu(d)$ + 数论分块。</li></ul><h2 id="例题-ABC020D-LCM-Rush"><a href="#例题-ABC020D-LCM-Rush" class="headerlink" title="例题 [ABC020D] LCM Rush"></a>例题 [ABC020D] LCM Rush</h2><p>求：<br>$$<br>\sum_{i &#x3D; 1}^n \operatorname{lcm}(n, k)<br>$$<br>经典操作：<br>$$<br>\sum_{i &#x3D; 1}^n \dfrac{i k}{\gcd(i, k)} &#x3D; k \sum_{i &#x3D; 1}^n \dfrac{i}{\gcd(i, k)}<br>$$<br>再一次经典操作，枚举 $\gcd$：<br>$$<br>\begin{align}<br>&amp; k \sum_{i &#x3D; 1}^n \sum_{d \mid k} [\gcd(i, k) &#x3D; d] \frac{i}{d} \newline<br>&#x3D; &amp; k \sum_{i &#x3D; 1}^n \sum_{d \mid k} [d \mid i]\left[\gcd\left(\frac{i}{d}, \frac{k}{d} \right) &#x3D; 1\right] \dfrac{i}{d}\newline<br>&#x3D; &amp; k \sum_{d \mid k} \sum_{i &#x3D; 1}^{\left\lfloor\frac {n} {d}\right\rfloor} \left[\gcd\left(i, \frac{k}{d} \right) &#x3D; 1\right] i<br>\end{align}<br>$$<br>先把最右侧的 $\sum$ 单独拿出来看，设 $f(n, m) &#x3D; \sum\limits_{i &#x3D; 1}^{n} \left[\gcd\left(i, m \right) &#x3D; 1\right] i$，则 $ans &#x3D; k \sum\limits_{d \mid k} f\left(\left\lfloor\frac {n} {d}\right\rfloor, \frac{k}{d}\right)$：<br>$$<br>\begin{align}<br>f(n, m) &#x3D; &amp;\sum\limits_{i &#x3D; 1}^{n} \left[\gcd\left(i, m \right) &#x3D; 1\right] i\newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^n i \sum_{d \mid \gcd\left(i, m \right)} \mu(d) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^n i \sum_{d \mid i, d\mid m} \mu(d) \newline<br>&#x3D; &amp; \sum_{d \mid m} \mu(d) \sum_{i &#x3D; 1}^{\left\lfloor\frac {n} {d}\right\rfloor} di\newline<br>&#x3D; &amp; \sum_{d \mid m} \mu(d)d \sum_{i &#x3D; 1}^{\left\lfloor\frac {n} {d}\right\rfloor}i<br>\end{align}<br>$$<br>直接就可做。注意到数据范围非常大，我们可以预处理 1 到 1e7 间的所有 $\mu$，其他的暴力算。这样时间复杂度大约是 $\mathcal{O}(\sqrt n)$。</p><h2 id="P1829-国家集训队-Crash的数字表格"><a href="#P1829-国家集训队-Crash的数字表格" class="headerlink" title="P1829 [国家集训队] Crash的数字表格"></a>P1829 [国家集训队] Crash的数字表格</h2><p>$1 \leq n, m \leq 10^7$，求：<br>$$<br>\sum_{i &#x3D; 1}^n \sum_{j &#x3D; 1}^m \operatorname{lcm}(i, j)<br>$$<br>替换 lcm：<br>$$<br>\sum_{i &#x3D; 1}^n \sum_{j &#x3D; 1}^m \dfrac{i \cdot j}{\gcd(i, j)}<br>$$<br>枚举 $\gcd$ 的值：<br>$$<br>\begin{align}<br>&amp; \sum_{i &#x3D; 1}^n \sum_{j &#x3D; 1}^m \sum_{d \mid i, d \mid j} [\gcd(i, j) &#x3D; d] \dfrac{i \cdot j}{d}\newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i, j) &#x3D; 1] i \cdot j \cdot d\newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n d \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} [\gcd(i, j) &#x3D; 1] i \cdot j<br>\end{align}<br>$$</p><p>我们把右边这部分单独拿出来，设 $f(n, m) &#x3D; \sum\limits_{i &#x3D; 1}^n \sum\limits_{j &#x3D; 1}^m [\gcd(i, j) &#x3D; 1] i \cdot j$：</p><p>$$<br>\begin{align}<br>f(n, m) &#x3D;&amp; \sum\limits_{i &#x3D; 1}^n \sum\limits_{j &#x3D; 1}^m [\gcd(i, j) &#x3D; 1] i \cdot j\newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^n \sum_{j &#x3D; 1}^m \sum_{d | i, d | j} \mu(d) \cdot i \cdot j<br>\end{align}<br>$$</p><p>进行一些变换，先枚举 $d$：<br>$$<br>\begin{align}<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n \mu(d) \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} i \cdot j \cdot d^2\newline<br>&#x3D; &amp; \sum_{d &#x3D; 1}^n \mu(d) d^2 \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i \sum_{j &#x3D; 1}^{\left\lfloor \frac{m}{d} \right\rfloor} j<br>\end{align}<br>$$<br>注意到这个式子前一个 $\sum$ 可以前缀和优化，后两个 $\sum$ 是等差数列，但是他有良好的范围：带下取整，因此可以数论分块。</p><p>至于整个式子：<br>$$<br>\sum_{d &#x3D; 1}^n d \cdot f\left(\left\lfloor \frac{n}{d} \right\rfloor, \left\lfloor \frac{m}{d} \right\rfloor \right)<br>$$<br>它也可以数论分块。所以整个是 $\mathcal{O}(n)$ 预处理 + 两次数论分块 $\mathcal{O}(n)$，最终时间复杂度 $\mathcal{O}(n)$（实际上还卡不到上界）。</p><h2 id="BJOJ2693-jzptab"><a href="#BJOJ2693-jzptab" class="headerlink" title="BJOJ2693 jzptab"></a>BJOJ2693 jzptab</h2><p>上题的加强版，添加了 $10^4$ 组多测。</p><p>继续考虑优化把式子展开：<br>$$<br>\sum_{d &#x3D; 1}^n d \cdot \sum_{t &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(t) t^2 \sum_{i &#x3D; 1}^{\left\lfloor \frac{n}{dt} \right\rfloor} i \sum_{j &#x3D; 1}^{\left\lfloor \frac{m}{dt} \right\rfloor} j<br>$$<br>设 $\operatorname{Sum}(n) &#x3D; \sum_{i &#x3D; 1}^{n} i$，得：<br>$$<br>\sum_{d &#x3D; 1}^n d \cdot \sum_{t &#x3D; 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(t) t^2 \operatorname{Sum}\left({\left\lfloor \frac{n}{dt} \right\rfloor}\right) \operatorname{Sum}\left({\left\lfloor \frac{m}{dt} \right\rfloor}\right)<br>$$<br>令 $dt &#x3D; T$：<br>$$<br>\begin{align}<br>&#x3D; &amp; \sum_{T &#x3D; 1}^n \operatorname{Sum}\left({\left\lfloor \frac{n}{T} \right\rfloor}\right) \operatorname{Sum}\left({\left\lfloor \frac{m}{T} \right\rfloor}\right) \sum_{d \mid T}^n d \cdot \mu\left(\frac{T}{d}\right) \left(\frac {T} {d}\right)^2\newline<br>&#x3D; &amp; \sum_{T &#x3D; 1}^n \operatorname{Sum}\left({\left\lfloor \frac{n}{T} \right\rfloor}\right) \operatorname{Sum}\left({\left\lfloor \frac{m}{T} \right\rfloor}\right) T \sum_{d \mid T} \mu(d) d<br>\end{align}<br>$$<br>设为 $f(T) &#x3D; \sum_{d \mid T} \mu(d)d$，得：<br>$$<br>&#x3D; \sum_{T &#x3D; 1}^n \operatorname{Sum}\left({\left\lfloor \frac{n}{T} \right\rfloor}\right) \operatorname{Sum}\left({\left\lfloor \frac{m}{T} \right\rfloor}\right) T \cdot f(T)<br>$$<br>尝试证明 $f(T)$ 是一个积性函数：<br>$$<br>f(p) &#x3D; \sum_{d \mid p} \mu(d)d \quad f(q) &#x3D; \sum_{d \mid q} \mu(d)d \qquad (\gcd(p, q) &#x3D; 1)\newline<br>$$<br>$$<br>\begin{align}<br>f(p) \cdot f(q) &amp; &#x3D; \left(\sum_{d \mid p} \mu(d)d\right) \left(\sum_{d \mid q} \mu(d)d\right)\newline<br>&amp; &#x3D; \sum_{d \mid p} \mu(d)d \sum_{t \mid q} \mu(t)t\newline<br>&amp; &#x3D; \sum_{d \mid p} \sum_{t \mid q} dt \cdot \mu(d) \mu(t)\newline<br>\end{align}<br>$$<br>$$<br>\gcd(p, q) &#x3D; 1 \Rightarrow \nexists \ d &#x3D; t \Rightarrow {d \mid d | p} \cap {t \mid t | q} &#x3D; \emptyset ,{d \mid d | p} \cup {t \mid t | q} &#x3D; {x \mid x | pq}<br>$$<br>$$<br>\Downarrow\newline<br>f(p) \cdot f(q) &#x3D; \sum_{d \mid pq} d \cdot \mu(d) &#x3D; f(pq)<br>$$</p><p>Q.E.D</p><p>我们来观察 $f$ 的一些性质：<br>$$<br>f(p) &#x3D; 1 - p, f(p^k) &#x3D; f(p) \quad(p \in \mathbb{P})<br>$$<br>然后就可以线性筛+数论分块了。</p><h2 id="【例题2】周期字符串"><a href="#【例题2】周期字符串" class="headerlink" title="【例题2】周期字符串"></a>【例题2】周期字符串</h2><blockquote><p>求长度为 $n$ 且仅包含小写英文字母（小写字母不一定要全部使用）且循环节长度恰为 $n$ 的字符串的个数。循环节就是最短的复制若干遍后拼起来跟原串相等的字符串。答案对 $10^9 + 7$ 取模。</p></blockquote><p>jpdh 的题，重要的在于转化以及状态设计。</p><p>设 $f(n)$ 为循环节恰好为 $n$ 的字符串个数，$g(n)$ 为长度为 $n$ 的字符串个数（$26^n$）。注意到 $g(n)$ 如果存在循环节，那么长度一定是 $n$ 因数，因此我们可以枚举循环节长度，根据加法原理：<br>$$<br>g(n) &#x3D; \sum_{d \mid n} f(n) &#x3D; (f * 1)(n) \Rightarrow f(n) &#x3D; (g * \mu)(n)<br>$$<br>裸的莫比乌斯反演，甚至是直接爆算 $\mu$。</p><h2 id="BJOJ2694-Lcm"><a href="#BJOJ2694-Lcm" class="headerlink" title="BJOJ2694 Lcm"></a>BJOJ2694 Lcm</h2><p>注意到题意有一个类似于莫比乌斯函数的东西，尝试让他用一个式子表示出来：<br>$$<br>\sum_{i &#x3D; 1}^A \sum_{j &#x3D; 1}^B \operatorname{lcm}(i, j) \mu^2(\gcd(i, j))<br>$$<br>推一推：<br>$$<br>\begin{align}<br>&#x3D; &amp; \sum_{i &#x3D; 1}^A \sum_{j &#x3D; 1}^B \frac{ij}{\gcd(i, j)}<br>\mu^2(\gcd(i, j)) \newline<br>&#x3D; &amp; \sum_{i &#x3D; 1}^A \sum_{j &#x3D; 1}^B \sum_{d \mid i} \mu^2(d)<br>\frac{ij}{d}[\gcd(i, j) &#x3D; d] \newline<br>&#x3D; &amp;  \sum_{d &#x3D; 1}^A \sum_{i &#x3D; 1}^{\left\lfloor \frac{A}{d}<br>\right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{B}{d} \right\rfloor}<br>\mu^2(d) ijd [\gcd(i, j) &#x3D; 1] \newline<br>&#x3D; &amp;  \sum_{d &#x3D; 1}^A \mu^2(d) d \sum_{i &#x3D; 1}^{\left\lfloor<br>\frac{A}{d} \right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{B}{d}<br>\right\rfloor} ij \sum_{t \mid i, t \mid j} \mu(t) \newline<br>&#x3D; &amp;  \sum_{d &#x3D; 1}^A \mu^2(d) d \sum_{t &#x3D; 1}^{\left\lfloor<br>\frac{A}{d} \right\rfloor} \sum_{i &#x3D; 1}^{\left\lfloor \frac{A}{dt}<br>\right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{B}{dt} \right\rfloor}<br>\mu(t) \cdot ijt^2 \newline<br>&#x3D; &amp;  \sum_{d &#x3D; 1}^A \mu^2(d) d \sum_{t &#x3D; 1}^{\left\lfloor<br>\frac{A}{d} \right\rfloor} \mu(t) t^2 \sum_{i &#x3D; 1}^{\left\lfloor<br>\frac{A}{dt} \right\rfloor} \sum_{j &#x3D; 1}^{\left\lfloor \frac{B}{dt}<br>\right\rfloor} ij \newline<br>\end{align}<br>$$<br>设 $S(n) &#x3D; \sum_{i &#x3D; 1}^ni$，并且 $T&#x3D;dt$：<br>$$<br>\begin{align}<br>&#x3D; &amp; \sum_{d &#x3D; 1}^A \mu^2(d) d \sum_{t &#x3D; 1}^{\left\lfloor \frac{A}{d}<br>\right\rfloor} \mu(t) t^2 S\left(\left\lfloor \frac{A}{d}<br>\right\rfloor\right) \cdot S\left(\left\lfloor \frac{B}{d}<br>\right\rfloor\right)\newline<br>&#x3D; &amp; \sum_{T &#x3D; 1}^A S\left(\left\lfloor \frac{A}{d}<br>\right\rfloor\right) \cdot S\left(\left\lfloor \frac{B}{d}<br>\right\rfloor\right) \sum_{d \mid T} \mu^2(d) d \cdot<br>\mu\left(\frac{T}{d}\right) \left(\frac{T}{d}\right)^2\newline<br>&#x3D; &amp; \sum_{T &#x3D; 1}^A S\left(\left\lfloor \frac{A}{d}<br>\right\rfloor\right) \cdot S\left(\left\lfloor \frac{B}{d}<br>\right\rfloor\right) T \sum_{d \mid T} \mu^2(d) \cdot<br>\mu\left(\frac{T}{d}\right) \left(\frac{T}{d}\right)<br>\end{align}<br>$$<br>可以发现后面又是一个卷积的形式，设它为 $g(T)$，卷积的两个函数都是积性函数，因此 $g$ 也是积性函数。我们来分析 $g(n)$：</p><ul><li>如果 $n$ 含有三个及以上个质因数，那么无论它如何拆分，总有一个 $\mu$ 会得 $0$，则 $g(n)&#x3D;0$；</li><li>如果 $n \in \mathbb P$，手玩发现 $g(n)&#x3D;−p^2+p$；</li><li>如果 $n&#x3D;p^2,p \in \mathbb P$，手玩得到 $g(n)&#x3D;−p^3$。</li></ul><p>观察完毕，$g$ 可以线性筛，整个可以数论分块。</p><h2 id="CF1139D-Steps-to-One"><a href="#CF1139D-Steps-to-One" class="headerlink" title="CF1139D Steps to One"></a>CF1139D Steps to One</h2><blockquote><p>给一个数列，每次随机选一个 $1$ 到 $m$ 之间的数加在数列末尾，数列中所有数的 $\gcd&#x3D;1$ 时停止，求期望长度。</p></blockquote><p>解法很多，这里介绍一种：</p><p>研究一下概率与期望之间的转换：</p><p>$$<br>\begin{aligned}<br>E(len) &amp; &#x3D; \sum_{i \ge 1} P(len &#x3D; i) \cdot i \newline<br>&amp; &#x3D; \sum_{i \ge 1} P(len &#x3D; i) \sum_{j &#x3D; 1}^i 1 \newline<br>&amp; &#x3D; \sum_{j \ge 1} \sum_{i \ge j}  P(len &#x3D; i) \newline<br>&amp; &#x3D; \sum_{i \ge 1} P(len \ge i) \newline<br>&amp; &#x3D; 1 + \sum_{i \ge 1} P(len &gt; i)<br>\end{aligned}<br>$$</p><p>然后我们把关于 $P$ 的单独拿出来看：<br>$$<br>\begin{align}<br>P(len &gt; i) &amp; &#x3D; P\left(\gcd \limits_{j &#x3D; 1}^i a_j &gt; 1 \right) \newline<br>&amp; &#x3D; 1 - P\left(\gcd \limits_{j &#x3D; 1}^i a_j &#x3D; 1 \right)\newline<br>&amp; &#x3D; \frac{\sum_{a_1 &#x3D; 1}^m\sum_{a_2 &#x3D; 1}^m\cdots\sum_{a_i &#x3D; 1}^m [\gcd_{j &#x3D; 1}^i a_j &#x3D; 1]}<br>{m^i}<br>\end{align}<br>$$<br>对后面那一坨莫反：<br>$$<br>\begin{align}<br>P(len &gt; i) &#x3D; &amp; 1 - \frac{\sum_d \sum_{a_1 &#x3D; 1}^m \cdots \sum_{a_i &#x3D; 1}^m [\gcd_{j &#x3D; 1}^i a_j &#x3D; d]}{m ^ i}\newline<br>&#x3D; &amp; 1 - \frac{\sum_d\sum_{a_1 &#x3D; 1}^{\lfloor\frac md\rfloor} \cdots \sum_{a_i &#x3D; 1}^{\lfloor\frac md\rfloor} \mu(d)}{m ^ i}\newline<br>&#x3D; &amp; 1 - \frac{\sum_d\mu(d)\lfloor\frac md\rfloor^i}{m ^ i}\newline<br>\end{align}<br>$$</p><p>注意到 $d &#x3D; 1$ 时 $\sum$ 里面的其实就是 $m^i$，所以可以进一步简写为：</p><p>$$<br>\begin{align}<br>&#x3D; &amp; - \frac{\sum_{d &#x3D; 2}^m\mu(d)\lfloor\frac md\rfloor^i}{m ^ i}<br>\end{align}<br>$$</p><p>然后回代到期望的式子，也就是：</p><p>$$<br>\begin{align}<br>E(len) &#x3D; &amp; 1 + \sum_{i &#x3D; 1}^{+\infty} P(len &gt; i)\newline<br>&#x3D; &amp; 1 - \sum_{i &#x3D; 1}^{+\infty}\frac{\sum_{d &#x3D; 2}^m\mu(d)\lfloor\frac md\rfloor^i}{m ^ i}\newline<br>&#x3D; &amp; 1 - \sum_{i &#x3D; 1}^{+\infty}\frac 1{m^i} \sum_{d &#x3D; 2}^m\mu(d)\left\lfloor\frac md\right\rfloor^i\newline<br>&#x3D; &amp; 1 - \sum_{d &#x3D; 2}^m \mu(d)\sum_{i &#x3D; 1}^{+\infty} \left(\frac {\left\lfloor\frac md\right\rfloor}{m} \right)^i\newline<br>\end{align}<br>$$</p><p>注意到最后边的部分是<strong>无限项等比数列求和</strong>，可以利用简单具体数学知识的得到：</p><p>$$<br>E(len) &#x3D; 1 - \sum_{d &#x3D; 2}^m \mu(d) \frac{m}{m - \left\lfloor\frac md\right\rfloor}<br>$$</p><p>$\mathcal O(m)$ 线性筛 $\mu$ 然后直接算就行，复杂度 $\mathcal O(m)$ <del>当然杜教一下也不是不行</del>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫队杂题</title>
    <link href="/2024/10/01/%E8%8E%AB%E9%98%9F%E6%9D%82%E9%A2%98/"/>
    <url>/2024/10/01/%E8%8E%AB%E9%98%9F%E6%9D%82%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="莫队的本质"><a href="#莫队的本质" class="headerlink" title="莫队的本质"></a>莫队的本质</h2><p>大部分参考资料认为，莫队指的是用于处理满足能够将 $[l, r]$ 的答案在 $\mathcal O(1)$ 时间复杂度内扩展到 $[l, r - 1][l, r + 1][l - 1, r][l + 1, r]$ 的问题的一种思想，并且允许离线。实际上，随着对莫队研究的不断深入，笔者认为莫队的过程<strong>并不一定是在</strong> $\mathcal O(1)$ <strong>时间复杂度内对答案的扩展，而是对可以用于求得答案的数据结构&#x2F;变量&#x2F;的扩展</strong>。所谓最终的答案可能并不能在莫队左右端点移动的情况下 $\mathcal O(1)$ 求出，而是以一种更高的复杂度在莫队移动完成、最终处理答案时获得。</p><p>我们结合莫队时间复杂度的分析来进一步体会以上理论：</p><p>设我们将询问分块的块长为 $d$，操作数为 $m$，按左端点分块，右端点在每个块内单调，从左右端点的移动分别考虑：</p><ul><li>左端点：卡满的情况是相邻两个询问恰好在一个块的两端，复杂度为 $\mathcal O(m \cdot d)$；</li><li>右端点：每一个块的移动最多是 $\mathcal O(n)$ 的，总时间复杂度为 $\mathcal O(n \cdot \frac{n}{d})$。</li></ul><p>两者加起来，则为 $\mathcal O(m \cdot d + n \cdot \frac{n}{d})$。根据均值不等式，$m \cdot d + n \cdot \frac{n}{d} \ge 2\sqrt{n^2m}$，等号成立当且仅当 $m \cdot d &#x3D; n \cdot \frac{n}{d}$ 即 $d &#x3D; \frac{n}{\sqrt m}$，此时莫队的时间复杂度为 $\mathcal O(n \sqrt m)$。</p><p>可以发现，莫队的时间复杂度分析成立在于 $\mathcal O(1)$ 移动左右端点，答案计算的时间复杂度与移动的复杂度成和的关系，这也启示我们利用一种 $\mathcal O(1)$ 修改，较慢复杂度查询的数据结构与莫队结合，一般都是块状数组（值域分块）或 bitset。</p><h2 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009] HH的项链"></a>P1972 [SDOI2009] HH的项链</h2><p>板板，但是一般的莫队过不去。利用经典 trick：<strong>记录一个数在序列中的前驱后继，若删除&#x2F;插入时前驱&#x2F;后继在当前区间之外则修改答案</strong>。有效利用 cache miss，跑得飞快。</p><h2 id="P3709-大爷的字符串题"><a href="#P3709-大爷的字符串题" class="headerlink" title="P3709 大爷的字符串题"></a>P3709 大爷的字符串题</h2><p>sb 题面。</p><blockquote><p>无修改求区间众数，离散化。</p></blockquote><p><del>左转[Violet]蒲公英分块</del>。</p><p>但是我们还是拿莫队做，维护的时候注意存一个出现个数的桶。方便判断一个数从区间删除之后是否需要更新答案。</p><h2 id="P1903-国家集训队-数颜色-维护队列"><a href="#P1903-国家集训队-数颜色-维护队列" class="headerlink" title="P1903 [国家集训队] 数颜色 &#x2F; 维护队列"></a>P1903 [国家集训队] 数颜色 &#x2F; 维护队列</h2><p>带修莫队。设 $l$ 为横轴，$r$ 为纵轴，普通莫队大概是这样：</p><p><img src="/img/71508.png" alt="图片"></p><p>那么进一步的，带修莫队即为引入一个时间维，移动过程中如果莫队的修改次数大于询问的修改次数，就把它改回来，否则改过去，以为莫队保证了可以 $\mathcal O(1)$ 扩展区间，那么修改一般也可以 $\mathcal O(1)$ 做（如果不可以就不能带修莫队）。</p><p>大概长这样：</p><p><img src="/img/71519.png" alt="图片"></p><p>块长一般都设为 $n^{\frac 2 3}$，证明不会。</p><h2 id="P3674-小清新人渣的本愿"><a href="#P3674-小清新人渣的本愿" class="headerlink" title="P3674 小清新人渣的本愿"></a>P3674 小清新人渣的本愿</h2><p>莫队 + <code>bitset</code>。</p><ul><li>减法：注意到 $a - b &#x3D; x$ 可以转换为 $a &#x3D; b + x$，开个 <code>bitset</code>，表示 $i$ 是否在区间内出现。如果条件满足，就相当于 <code>bitset</code> 上的第 $i$ 位和 $i + x$ 位都是 $1$。不难发现这就是一个左移操作然后取与（<code>&amp;</code>）；</li><li>加法：与减法同理，可以再开一个 <code>bitset</code> 表示 $10000 - i$ 是否在区间内出现，如出一辙的右移 + 取与；</li><li>乘法：枚举因数，直接查询，复杂度 $\mathcal O(\sqrt x)$。</li></ul><p><img src="/img/4629.png" alt="图片"></p><h2 id="P5355-Ynoi2017-由乃的玉米田"><a href="#P5355-Ynoi2017-由乃的玉米田" class="headerlink" title="P5355 [Ynoi2017] 由乃的玉米田"></a>P5355 [Ynoi2017] 由乃的玉米田</h2><p>比上一题多了一个除法。</p><p>采用类似于根号分治的思想，对于 $x &gt; \sqrt{N}$，直接枚举倍数即可，复杂度 $\mathcal O(\frac{N}{x}) \le O(\sqrt{N})$；对于 $x \le \sqrt{N}$，对每一个 $x$ 维护一个 <code>lst[x][i]</code>，表示满足 $\frac {a_i} {a_j} &#x3D; x (i \le j)$ 的 $i$ 的最大位置。具体的：遍历序列时存一个 <code>pos</code> 表示在 $i$ 之前每个值出现的位置，使用 <code>lst[x][i - 1], pos[a[i] * x], pos[a[i] / x]</code> 更新 <code>lst[x][i]</code>。</p><p>甚至不用卡常。</p><p><img src="/img/58222.png" alt="图片"></p>]]></content>
    
    
    
    <tags>
      
      <tag>分块</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
